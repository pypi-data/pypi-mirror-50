"""A *PLX* file contains the following binary structure:

1. A main file header with various metadata, such as the date of the recording, comment, the acquisition software, the
   version of the file, etc. These fields are specified by :class:`Header`.
2. Arrays of timestamps for various event, slow waveform, and spike channels, as described by :class:`Counts`.
3. Three variable-length sequences of headers for

   1. Spike channels (:class:`SpikeHeader`)
   2. Event channels (:class:`EventHeader`)
   3. Slow waveform channels (:class:`SlowHeader`)

   The number of elements of each header type are given by the :class:`Header.num_dsp_channels`,
   :class:`Header.num_event_channels`, and :class:`Header.num_slow_channels`, respectively.

4. Finally, a sequence of data blocks, each preceded by a header (:class:`DataBlockHeader`) that describes the structure
   of the data block (number of bytes that follow) and the channel (whether it be a spike, event, or slow waveform one)
   to which it belongs. Data blocks come in no particular order regarding channel type and number, but they are usually
   chronologically ordered (increasing timestamp value).

All of the classes mentioned above are either subclasses of :class:`recparse.Record` or
:class:`recparse.RecordArray`, and they additionally define a ``dtype`` attribute that corresponds to a `Numpy
data-type`_ that may be used to parse the data from an open *PLX* file using Numpy's :func:`numpy.frombuf` or from the
parts exported by :mod:`plx.export` using :func:`numpy.fromfile`, for instance.

Most of the information reported in this documentation and assumed in the implementation of this module comes from the
following references: :cite:`PLX,OMNIPLEX`. The latter describes the following types of channels:

SPK:
    Extracted spike waveforms, the result of performing spike detection on a SPKC source.

WB:
    Continuously digitized wideband neural data from a DHP unit or an A/D device, such as a DigiAmp Amplifier.

SPKC:
    The result of highpass filtering and optional lowpass filtering a WB source, i.e. the "spike-filtered" continuous
    signal.

FP:
    The result of lowpass filtering and optional highpass filtering a WB source, i.e. the field potentials.

AI:
    Continuously digitized non-neural data, typically at a low sampling rate (e.g. 1 kHz), e.g. eye position, etc.

EVT:
    Individual digital events, e.g. discrete single-bit events or strobed multi-bit data words.

KBD:
    Similar to single-bit digital events, but generated by pressing Alt-1 through Alt-8 on the keyboard, for manually
    marking events during an experiment.

CPX:
    Data that is generated by a CinePlex System and sent to the OmniPlex System to be included in recordings.

Channels are usually named by these identifiers, followed by a two-digit channel number.

.. note::
    It is possible that other types of equipment by Plexon Inc. use other channel types with different naming
    conventions. However, our dataset only contains recordings from OmniPlexÂ® equipment, so we implicitly assume that
    these conventions hold for every *PLX* file that is possibly used with our code.

.. _Numpy data-type: https://docs.scipy.org/doc/numpy-1.15.1/reference/arrays.dtypes.html
"""

import collections
import datetime
import enum
import numpy
import pint
import struct
import wrapt

from recparse import FieldSpec, Record

# TODO: This symbol should actually be exported by the _plx module
TIMESTAMP_ATTR_DTYPE = numpy.uint64


class _UnitRegistryProxy(wrapt.ObjectProxy):
    """Class of objects that act as a proxy to a :class:`pint.UnitRegistry` instance.
    """

    def set_registry(self, registry):
        """Replace
        """
        self.__wrapped__ = registry


units = _UnitRegistryProxy(pint.UnitRegistry())


class CountSpec(
    collections.namedtuple(
        "CountSpec", "name struct_type property_name dtype shape offset"
    )
):
    """Special case of :class:`recparse.FieldSpec` that supports accessing properties as Numpy arrays.

    Parameters
    ----------
    name: str
        Name of field. It will be accessible within the resulting record type as :code`rec[name]`.

    struct_type: str
        A format code compatible with the :mod:`struct` module. This should be a single letter code, that is, alignment
        specifiers may be given, but there should be no numbers.

    property_name: str, optional
        If this is specified, a read/write property for accessing this field (as Numpy array of proper dimension and
        type) will be created in the resulting record type. The field will be accessible as :code:`rec.property_name`.

    dtype: Numpy type
        The basic numpy type corresponding to ``struct_format``. E.g. if ``struct_format='i'``, then ``dtype=i4`` or
        ``dtype=numpy.int32`` are appropriate.

    shape: tuple
        Shape of corresponding numpy array.

    offset: int, ignored
        This parameter is ignored during record specification. It is modified by the :class:`recparse.RecordMeta` metaclass
        during record class creation to reflect the correct offset of each field, which depends on the order in which
        fields are specified.
    """

    def __new__(cls, name, struct_type, property_name, dtype, shape, offset=None):
        return super().__new__(
            cls, name, struct_type, property_name, dtype, shape, offset
        )

    @property
    def length(self):
        return numpy.prod(self.shape)

    @property
    def size(self):
        """Size (in bytes) of this field.
        """
        return struct.calcsize(self.struct_format)

    @property
    def struct_format(self):
        """The full :mod:`struct` format (including numbers) of this field.
        """
        return "{}{}".format(self.length, self.struct_type)

    def property_getter(self, record):
        return numpy.frombuffer(
            record.buffer, dtype=self.dtype, count=self.length, offset=self.offset
        ).reshape(self.shape)

    def with_offset(self, offset):
        return self.__class__(*self[:5], offset=offset)


class Counts(Record):
    """
    .. warning::

        The section keys defined by :class:`CountSpec` instances returned from :meth:`fields` correspond to flat arrays.
        In other words, the ``TSCounts``, ``WFCounts``, and ``EVCounts`` field descriptors do not give access to
        correctly-shaped Numpy arrays. To retrieve their content as appropriately shaped arrays, use the ``timestamps``,
        ``waveforms``, and ``events`` properties, instead.
    """

    FIELDS = [
        CountSpec("TSCounts", "i", "timestamps", numpy.int32, (130, 5)),
        CountSpec("WFCounts", "i", "waveforms", numpy.int32, (130, 5)),
        CountSpec("EVCounts", "i", "events", numpy.int32, (512,)),
    ]
    dtype = numpy.dtype(
        [
            ("timestamps", "(130,5)i4"),
            ("waveforms", "(130,5)i4"),
            ("events", "(512,)i4"),
        ]
    )


class DataBlockHeader(Record):
    FIELDS = [
        FieldSpec("Type", "h"),
        FieldSpec("TimestampUpper", "H"),
        FieldSpec("TimestampLower", "I"),
        FieldSpec("Channel", "h", property_name="channel"),
        FieldSpec("Unit", "h", property_name="unit"),
        FieldSpec("NoWf", "h", property_name="no_wf"),
        FieldSpec("NoWoWf", "h", property_name="no_words_wf"),
    ]
    timestamp_dtype = TIMESTAMP_ATTR_DTYPE

    class Type(enum.IntEnum):
        SPIKE = 1
        EVENT = 4
        SLOW = 5

    @property
    def bytes_following(self):
        return 2 * self.no_wf * self.no_words_wf

    @property
    def type(self):
        return self.Type(self["Type"])

    @property
    def timestamp(self):
        return self["TimestampUpper"] << 32 | self["TimestampLower"]


class EventHeader(Record):
    FIELDS = [
        FieldSpec("Name", "32s", property_name="name"),
        FieldSpec("Channel", "i", property_name="channel"),
        FieldSpec("Comment", "128s", property_name="comment"),
    ]
    SIZE = 296
    dtype = numpy.dtype(
        [("Name", "S32"), ("Channel", "i"), ("Comment", "S128"), ("Padding", "(132,)b")]
    )


class Header(Record):
    FIELDS = [
        FieldSpec("MagicNumber", "I", property_name="magic_number"),
        FieldSpec("Version", "i", property_name="version"),
        FieldSpec("Comment", "128s", property_name="comment"),
        FieldSpec("ADFrequency", "i"),
        FieldSpec("NumDSPChannels", "i", property_name="num_dsp_channels"),
        FieldSpec("NumEventChannels", "i", property_name="num_event_channels"),
        FieldSpec("NumSlowChannels", "i", property_name="num_slow_channels"),
        FieldSpec("NumPointsWave", "i", property_name="num_points_wave"),
        FieldSpec("NumPointsPreThr", "i", property_name="num_points_pre_thr"),
        FieldSpec("Year", "i"),
        FieldSpec("Month", "i"),
        FieldSpec("Day", "i"),
        FieldSpec("Hour", "i"),
        FieldSpec("Minute", "i"),
        FieldSpec("Second", "i"),
        FieldSpec("FastRead", "i"),
        FieldSpec("WaveformFreq", "i"),
        FieldSpec("LastTimestamp", "d"),
        FieldSpec("Trodalness", "b", property_name="trodalness"),
        FieldSpec("DataTrodalness", "b", property_name="data_trodalness"),
        FieldSpec("BitsPerSpikeSample", "b", property_name="bits_per_spike_sample"),
        FieldSpec("BitsPerSlowSample", "b", property_name="bits_per_slow_sample"),
        FieldSpec("SpikeMaxMagnitudeMV", "H"),
        FieldSpec("SlowMaxMagnitudeMV", "H"),
        FieldSpec("SpikePreAmpGain", "H", property_name="spike_pream_gain"),
    ]
    SIZE = 256
    dtype = numpy.dtype(
        [
            ("MagicNumber", "u4"),
            ("Version", "i4"),
            ("Comment", "S128"),
            ("ADFrequency", "i4"),
            ("NumDSPChannels", "i4"),
            ("NumEventChannels", "i4"),
            ("NumSlowChannels", "i4"),
            ("NumPointsWave", "i4"),
            ("NumPointsPreThr", "i4"),
            ("Year", "i4"),
            ("Month", "i4"),
            ("Day", "i4"),
            ("Hour", "i4"),
            ("Minute", "i4"),
            ("Second", "i4"),
            ("FastRead", "i4"),
            ("WaveformFreq", "i4"),
            ("LastTimestamp", "f8"),
            ("Trodalness", "i1"),
            ("DataTrodalness", "i1"),
            ("BitsPerSpikeSample", "i1"),
            ("BitsPerSlowSample", "i1"),
            ("SpikeMaxMagnitudeMV", "u2"),
            ("SlowMaxMagnitudeMV", "u2"),
            ("SpikePreAmpGain", "u2"),
            ("Padding", "(46,)b"),
        ]
    )

    @property
    def ad_frequency(self):
        return self["ADFrequency"] * units.hertz

    @property
    def date(self):
        return datetime.date(self["Year"], self["Month"], self["Day"])

    @property
    def datetime(self):
        return datetime.datetime.combine(self.date, self.time)

    @property
    def fast_read(self):
        return bool(self["FastRead"])

    @property
    def last_timestamp(self):
        return int(self["LastTimestamp"])

    @property
    def slow_max_magnitude(self):
        return self["SlowMaxMagnitudeMV"] * units.millivolt

    @property
    def spike_max_magnitude(self):
        return self["SpikeMaxMagnitudeMV"] * units.millivolt

    @property
    def time(self):
        return datetime.datetime(self["Hour"], self["Minute"], self["Second"])

    @property
    def waveform_freq(self):
        return self["WaveformFreq"] * units.hertz


class SlowHeader(Record):
    """Headers of slow waveform channels.
    """

    FIELDS = [
        FieldSpec("Name", "32s", property_name="name"),
        FieldSpec("Channel", "i", property_name="channel"),
        FieldSpec("ADFreq", "i"),
        FieldSpec("Gain", "i", property_name="gain"),
        FieldSpec("Enabled", "i"),
        FieldSpec("PreAmpGain", "i", property_name="pre_amp_gain"),
        FieldSpec("SpikeChannel", "i", property_name="spike_channel"),
        FieldSpec("Comment", "128s", property_name="comment"),
    ]
    SIZE = 296
    dtype = numpy.dtype(
        [
            ("Name", "S32"),
            ("Channel", "i4"),
            ("ADFreq", "i4"),
            ("Gain", "i4"),
            ("Enabled", "i4"),
            ("PreAmpGain", "i4"),
            ("SpikeChannel", "i4"),
            ("Comment", "S128"),
            ("Padding", "(112,)b"),
        ]
    )

    @property
    def ad_frequency(self):
        return self["ADFreq"] * units.hertz

    @property
    def enabled(self):
        return bool(self["Enabled"])


class SpikeHeader(Record):
    FIELDS = [
        FieldSpec("Name", "32s", property_name="name"),
        FieldSpec("SIGName", "32s", property_name="sig_name"),
        FieldSpec("Channel", "i", property_name="channel"),
        FieldSpec("WFRate", "i"),
        FieldSpec("SIG", "i", property_name="sig"),
        FieldSpec("Ref", "i", property_name="ref"),
        FieldSpec("Gain", "i", property_name="gain"),
        FieldSpec("Filter", "i"),
        FieldSpec("Threshold", "i", property_name="threshold"),
        FieldSpec("Method", "i"),
        FieldSpec("NUnits", "i", property_name="no_units"),
        FieldSpec("Template", "%dh" % (5 * 64)),
        FieldSpec("Fit", "%di" % 5),
        FieldSpec("SortWidth", "i"),
        FieldSpec("Boxes", "%dh" % (5 * 2 * 4)),
        FieldSpec("SortBeg", "i"),
        FieldSpec("Comment", "128s", property_name="comment"),
    ]
    SIZE = 1020
    dtype = numpy.dtype(
        [
            ("Name", "S32"),
            ("SIGName", "S32"),
            ("Channel", "i4"),
            ("WFRate", "i4"),
            ("SIG", "i4"),
            ("Ref", "i4"),
            ("Gain", "i4"),
            ("Filter", "i4"),
            ("Threshold", "i4"),
            ("Method", "i4"),
            ("NUnits", "i4"),
            ("Template", "(5,64)i2"),
            ("Fit", "(5,)i4"),
            ("SortWidth", "i4"),
            ("Boxes", "(5,2,4)i2"),
            ("SortBeg", "i4"),
            ("Comment", "S128"),
            ("Padding", "(44,)b"),
        ]
    )

    class SortMode(enum.IntEnum):
        NONE = 0
        BOXES = 1
        TEMPLATES = 2

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        if self.sort_method == self.SortMode.BOXES:
            self.boxes = numpy.array(self["Boxes"], dtype=numpy.int16).reshape(
                (5, 2, 4)
            )
            self.sort_begin = self["SortBeg"]
        elif self.sort_method == self.SortMode.TEMPLATES:
            self.templates = numpy.array(self["Template"], dtype=numpy.int16).reshape(
                (5, 64)
            )
            self.fit = numpy.array(self["Fit"], dtype=numpy.int32).reshape((5,))
            self.sort_width = self["SortWidth"]

    @property
    def filter(self):
        return bool(self["Fiter"])

    @property
    def sort_method(self):
        return self.SortMode(self["Method"])

    @property
    def wf_rate(self):
        return self["WFRate"] * units.hertz
