##########################################################################
# NSAp - Copyright (C) CEA, 2018
# Distributed under the terms of the CeCILL-B license, as published by
# the CEA-CNRS-INRIA. Refer to the LICENSE file or to
# http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html
# for details.
##########################################################################

# System import
import os
import glob
import re
import shutil
import subprocess
import multiprocessing

# Third-Party import
import nibabel

# Package import
from pyconnectome.wrapper import FSLWrapper
from pyconnectome import DEFAULT_FSL_PATH
from joblib import Parallel, delayed


"""
DTI-Tk Preprocessing
"""


def dtitk_version():
    """ Return the DTI-TK version.

    Returns
    -------
    version: str
        the DTI-TK version.
    """
    # Check DTI-TK has been configured so the command can be found
    process = subprocess.Popen(["which", "TVtool"],
                               stdout=subprocess.PIPE,
                               stderr=subprocess.PIPE)
    stdout, stderr = process.communicate()
    exitcode = process.returncode
    if exitcode != 0:
        raise ValueError("Please check DTI-TK is installed properly.")
    return stdout.split(os.sep)[-3]


def dtitk_import_tensors(basename, output_dir, tool="FSL",
                         outliers=True, spd=True, origin=True,
                         isotropic=False):
    """ Runs dti-tk preprocessing steps on a tensor file:
    1) Convert file to dti-tk nifti tensor format.
    2) Put image file origin to [0, 0, 0].
    3) Resample image to isotropic voxels.

    For more information, please refer to :
    http://dti-tk.sourceforge.net/pmwiki/pmwiki.php?n=Documentation.BeforeReg

    Parameters
    ----------
    basename: str
        basename for FSL-generated DTI eigensystem files (e.g: dtifit).
    output_dir: str
        path to output directory.
    tool: str
        tool used to generate the DTI eigensystem files.
    outliers: bool
        Removes outlier voxels.
    spd: bool
        Checks if diffusion tensor has a symmetric and
        positive-definite matrix. Creates a new symmetric and
        positive-definite matrix.
    origin: bool
        Puts volume file origin to [0, 0, 0].
    isotropic: bool
        Puts voxels to isotropic dimensions.

    Returns
    -------
    tensor_dtitk: str
        path to the modified tensor image that can be used for dtitk
        processing.
    """
    if tool == "FSL":
        # Convert freesurfer tensor image data to dti-tk nifti tensor
        tensor_dtitk = convert_fsl_to_nifti_tensor_format(
            basename=basename,
            out_dir=output_dir)

        # Convert the diffusivity unit to DTITK compatible one
        multiplier = 1000
        cmd = "TVtool -in {0} -scale {1} -out {0}".format(
            tensor_dtitk, multiplier)
        os.system(cmd)

        # Assume that the brain extraction has been done
        if outliers:
            # Remove outliers quantified with tensor norm
            tensor_norm, tensor_non_outliers = remove_outliers(
                tensor_dtitk=tensor_dtitk,
                norm_outlier_threshold=100)

        if spd:
            # Convert to SPD
            check_spd(tensor_dtitk=tensor_dtitk)

        if origin:
            # Put origin to [0, 0, 0]
            TVAdjustVoxelspace(
                img=tensor_dtitk,
                out_file=tensor_dtitk,
                origin=[0, 0, 0])

        if isotropic:
            # Resample to isotropic voxels
            tensor_dtitk_img = nibabel.load(tensor_dtitk)
            vsize_init = tensor_dtitk_img.header.get_zooms()
            size_init = tensor_dtitk_img.shape
            vsize = [1, 1, 1]
            size = []
            for i in range(len(size_init[:3])):
                size.append(size_init[i]*vsize_init[i]/vsize[i])
            TVResample(
                img_file=tensor_dtitk,
                vsize=vsize,
                size=size,
                out_file=tensor_dtitk)
    else:
        raise NotImplementedError(
            "Interoperability between DTI-TK and {0} has not been implemented"
            " yet.".format(tool))

    return tensor_dtitk


def convert_fsl_to_nifti_tensor_format(basename, out_dir, tool="FSL"):
    """ Wraps DTI-TK commands and Convert FSL-formatted tensor outputs
    (*_V{1,2,3}.nii.gz and *_L{1,2,3}.nii.gz) to NIfTI tensor format
    and preprocess appropriately

    Parameters
    ----------
    basename: str
        basename for the DTI eigensystem files (e.g: dtifit).
    out_dir: str
        output directory path for files generated by nifti format conversion
        and diffusion units scaling. Files generated by the options outliers,
        spd and origin will be created in the volume input file directory.
    tool: str
        tool used to generate the the DTI eigensystem files

    Returns
    -------
    tensor_dtitk: str
        path to the created .nii file usable by dti-tk.
    """
    if not os.path.isdir(out_dir):
        raise ValueError("convert_fsl_to_nifti_tensor_format: invalid"
                         " output directory {0}...".format(out_dir))
    tensor_dtitk = "{0}_dtitk.nii.gz".format(
        os.path.join(out_dir, os.path.basename(basename)))

    # Convert from FSL eigensystem (_V{1,2,3} and _L{1,2,3}) to
    # NIfTI tensor format
    cmd = "TVFromEigenSystem -basename {0} -out {1} -type FSL".format(
          basename, tensor_dtitk)
    os.system(cmd)

    return tensor_dtitk


def remove_outliers(tensor_dtitk, norm_outlier_threshold=100):
    """ Wraps DTI-TK commands to identify outliers voxels and remove them by
    masking.

    Parameters
    ----------
    tensor_dtitk: str
        path to dti volume in NIFTI tensor format.
    norm_outlier_threshold: float
        threshold for outliers.

    Returns
    -------
    tensor_norm: str
        path to the norm nii file of tensor_dtitk.
    tensor_non_outliers: str
        path to the outliers nii file of tensor_dtitk.
    """
    print("Removing outliers for volume {0}...".format(tensor_dtitk))
    tensor_norm = re.sub(".nii.gz", "_norm.nii.gz", tensor_dtitk)
    cmd = "TVtool -in {0} -norm -out {1}".format(tensor_dtitk, tensor_norm)
    os.system(cmd)

    # Print statistics
    cmd = "SVtool -in {0} -stats".format(tensor_norm)
    os.system(cmd)

    # Binary thresholding to identify outlier voxels
    tensor_non_outliers = re.sub(".nii.gz", "_non_outliers.nii.gz",
                                 tensor_dtitk)
    cmd = "BinaryThresholdImageFilter {0} {1} 0 {2} 1 0".format(
        tensor_norm, tensor_non_outliers, str(norm_outlier_threshold))
    os.system(cmd)

    # Remove outlier voxels by masking
    cmd = "TVtool -in {0} -mask {1} -out {0}".format(tensor_dtitk,
                                                     tensor_non_outliers)
    os.system(cmd)
    print("Outliers removed...")

    return tensor_norm, tensor_non_outliers


def check_spd(tensor_dtitk):
    """ Wraps DTI-TK command TVtool to check if diffusion tensor has a
    symmetric and positive-definite matrix, or SPD.

    Parameters
    ----------
    tensor_dtitk: str
        path to dtitk volume.
    """
    cmd = "TVtool -in {0} -spd -out {0}".format(tensor_dtitk)
    os.system(cmd)


def TVAdjustVoxelspace(img, out_file, origin):
    """ Wraps DTI-TK command TVAdjustVoxelspace to put origin to [0, 0, 0].

    Parameters
    ----------
    img: str
        path to .nii file.
    out_file: str
        path to output file.
    origin: list
        list containing origin position e.g [0, 0, 0]
    """
    cmd = "TVAdjustVoxelspace -in {0} -origin {2} {3} {4} -out {1}".format(
          img, out_file, origin[0], origin[1], origin[2])
    os.system(cmd)


def TVResample(img_file, vsize, size, out_file):
    """ Wraps DTI-TK command TVResample to resample an image given a voxel
    size.

    Parameters
    ----------
    tensor_file: str
        path to a .nii file.
    vsize: array N(1,3)
        array of voxel dimensions.
    size: array N(1,3)
        output image size.
    out_file: str
        path to output file.
    """
    cmd = ("TVResample -in {0} -vsize {1} {2} {3} -size {4} {5} {6} "
           " -out {7}".format(img_file, vsize[0], vsize[1],
                              vsize[2], size[0], size[1], size[2], out_file))
    os.system(cmd)


"""
DTI-Tk template creation
"""


def dti_template_bootstrap(template, subjects_file):
    """ Wraps DTI-TK script dti_template_bootstrap which bootstrap an initial
    template estimate from a set of DTI volumes.

    Parameters
    ----------
    template: str
        the path to the template file.
    subjects_file: str
        the path to the file listing all subjects dti files (already
        preprocessed for dti-tk).
    Returns
    -------
    output_template: str
        path to the created template.
    """
    cmd = ["dti_template_bootstrap", template, subjects_file]
    cmd = " ".join(cmd)
    os.system(cmd)
    output_dir = os.path.dirname(template)
    output_template = os.path.join(output_dir, "mean_initial.nii.gz")
    return output_template


def bootstrap_template_from_dti(subjects, out_template, typep="ORIGINAL",
                                interp="LEI"):
    """ Wraps DTI-TK TVMean command and create a boostrap template from dti
    files.

    Parameters
    ----------
    subjects: str
        path to a file listing the subjects dti volumes preprocessed for
        dti-tk.
    out_template: str
        path to the output template.
    typep: str
        can be ORIGINAL or DYADIC. Default is ORIGINAL.
    interp: str
        type of interpolation. Can be euclidian (EI) or log-euclidian
        interpolation (LEI). Default is LEI.

    Returns
    -------
    out_template: str
        path to the output template.
    """
    cmd = ["TVMean", "-in", subjects, "-out", out_template, "-type", typep,
           "-interp", interp]
    cmd = " ".join(cmd)
    os.system(cmd)
    return out_template


def dtitk_create_mean_template(subject_list, out_path,
                               template_dim=[128, 128, 64]):
    """ Uses DTI-TK command TVMean and create a template from a list of
    DTI NIFTI files and resample it with voxel dimensions being powers of
    2.

    Parameters
    ----------
    subject_list: str
        the path to the list of subjects' DTI nii files.
    out_path: str
        the path to the created template.
    template_dim: array
        new template dimensions, must be power of 2. If created template
        dimensions are power of 2, there is no need to resample.
    Returns
    -------
    template: str
        path to the created template.
    """
    # Create the boostrap template
    template = os.path.join(out_path, "mean_initial.nii.gz")
    template = bootstrap_template_from_dti(subject_list, template)

    # Resample the template into a voxel space with the voxel dimensions being
    # powers of 2 (DTI-TK mandatory step).
    # The volumes that will be registered on the template do NOT need to have
    # powers of 2 volume dimensions.
    template_img = nibabel.load(template)
    template_img_shape = template_img.get_data().shape[:3]
    template_img_voxel_sizes = template_img.header.get_zooms()[:3]
    new_voxel_dim = [1, 1, 1]
    for i, dim in enumerate(template_dim):
        new_voxel_dim[i] = ((template_dim[i] / template_img_shape[i]) *
                            template_img_voxel_sizes[i])
    new_voxel_dim = "{0} {1} {2}".format(
        new_voxel_dim[0], new_voxel_dim[1], new_voxel_dim[2])
    template_dim = "{0} {1} {2}".format(
        template_dim[0], template_dim[1], template_dim[2])
    cmd = ["TVResample", "-in", template, "-align", "center", "-size",
           template_dim, "-vsize", new_voxel_dim]
    cmd = " ".join(cmd)
    os.system(cmd)

    return template


def rigid_alignment_population(template, subjects, output_dir, SMOption,
                               no_of_iterations, optimized=False):
    """ Wraps DTI-TK script dti_rigid_population and rigidly align a set of
    DTI volume (subjects) to a template. The optimized templates will be
    saved as mean_rigid{1,2,..,no_of_iterations}.nii.gz. The aligned
    volumes are computed and their filenames are stored in "subjs_aff.txt".

    Parameters
    ----------
    template: str
        the path to the template.
    subject: str
        the path to the text file list of DTI-TK nii files.
    output_dir: str
        the path to the output directory.
    SMOption: str
        the similarity metric you'd like to use for assessing the quality of
        alignment (Euclidian Distance - EDS,  Deviatoric Distance Squared - DDS
        Geometric Distance Squared - GDS,
        Normalized Mutual Information between tensor components - NMI).
    no_of_iterations: int
        the number of iterations to optimize the template over the whole
        process.
    optimized: bool (optional, default False)
        if the input template is already optimized.

    Returns
    -------
    output: str
        path to the mean rigid template of tensor files.
    """
    if not os.getcwd() == output_dir:
        os.chdir(output_dir)

    if optimized:
        cmd = "dti_rigid_population {0} {1} {2}".format(template, subjects,
                                                        SMOption)
    else:
        cmd = "dti_rigid_population {0} {1} {2} {3}".format(template, subjects,
                                                            SMOption,
                                                            no_of_iterations)
    os.system(cmd)
    output = os.path.join(output_dir,
                          "mean_rigid{0}.nii.gz".format(no_of_iterations))
    return output


def affine_alignment_population(template, subjects_dti_file, output_dir,
                                SMOption, no_of_iterations):
    """ Wraps DTI-TK script dti_affine_population and affinely align a set of
    DTI volume (subjects) to a template. The optimized templates will be
    saved as mean_affine{1,2,..,no_of_iterations}.nii.gz. The aligned
    volumes are computed and their filenames are stored in "subjs_aff.txt".

    Parameters
    ----------
    template: str
        the path to the template.
    subjects_dti_file: str
        the path to the text file list of DTI-TK nii files.
    output_dir: str
        the path to the output directory.
    SMOption: str
        the similarity metric you'd like to use for assessing the quality of
        alignment (Euclidian Distance - EDS,  Deviatoric Distance Squared - DDS
        Geometric Distance Squared - GDS,
        Normalized Mutual Information between tensor components - NMI).
    no_of_iterations: int
        the number of iterations to optimize the template over the whole
        process.

    Returns
    -------
    affine_template: str
        the path to the generated affine template.
    subjects_dti_aff_file: str
        the path to the list of subjects dti volumes registered to the affine
        template.
    """
    if not os.getcwd() == output_dir:
        os.chdir(output_dir)
    cmd = "dti_affine_population {0} {1} {2} {3}".format(
        template, subjects_dti_file, SMOption, no_of_iterations)
    os.system(cmd)
    output_dir = os.path.dirname(subjects_dti_file)
    affine_template = os.path.join(
        output_dir, "mean_affine{0}.nii.gz".format(no_of_iterations))
    subjects_dti_aff_file = subjects_dti_file.replace(".txt", "_aff.txt")
    return affine_template, subjects_dti_aff_file


def deformable_alignment_population(affine_template, subjects_affine,
                                    output_dir, ftol):
    """ Wraps DTI-TK script dti_diffeomorphic_population which improves
    alignment by removing size or shape differences between local
    structures.

    Parameters
    ----------
    affine_template: str
        the path to the template generated after affine alignment.
    subjects_affine: str
        the path to the subject list generated after affine alignment.
    output_dir: str
        the path to the output directory.
    ftol: float
        the minimum amount of change in the cost function.

    Returns
    -------
    deformable_template: str
        the path to the diffeormorphic registration template.
    mask: str
        the path to a binary image that has 0 for background voxels and 1 for
        brain tissue voxels.
    """
    if not os.getcwd() == output_dir:
        os.chdir(output_dir)

    # Generate binary mask of brain tissue
    # > Compute the trace map of the template image
    trace_affine_template = re.sub(".nii.gz", "_tr.nii.gz", affine_template)
    cmd = "TVtool -in {0} -tr -out {1}".format(affine_template,
                                               trace_affine_template)
    os.system(cmd)
    # > Binary threshold the trace map to generate the mask image.
    mask = os.path.join(os.path.dirname(affine_template), "mask.nii.gz")
    cmd = ("BinaryThresholdImageFilter {0} {1} 0.01 100 1 0"
           .format(trace_affine_template, mask))
    os.system(cmd)

    # Spatial normalization
    cmd = ("dti_diffeomorphic_population {0} {1} {2} {3}".format(
            affine_template, subjects_affine, mask, ftol))
    os.system(cmd)
    deformable_template = os.path.join(
        output_dir, "mean_diffeomorphic_initial6.nii.gz")
    return deformable_template, mask


"""
DTI-Tk Registration
"""


def dti_rigid_reg(template, subject, output_dir, SMoption="EDS",
                  sep=[4.0, 4.0, 4.0], ftol=0.01, useInTrans=False):
    """ Wraps DTI-TK script dti_rigid_reg and rigidly align a subject
    DTI volume to a template.

    Parameters
    ----------
    template: str
        the path to the template.
    subject: str
        the path to the subject DWI volume.
    output_dir: str
        the path to the output directory.
    SMOption: str
        the similarity metric you'd like to use for assessing the quality of
        alignment (Euclidian Distance - EDS,  Deviatoric Distance Squared - DDS
        Geometric Distance Squared - GDS,
        Normalized Mutual Information between tensor components - NMI).
    sep: float array
        the distance between the sample points in the volume for the evaluation
        of image similarity (mm).
    ftol: float
        the minimum amount of change in the cost function as a fraction of the
        previous value at the previous iteration for the registration
        optimization to stop.
    useInTrans: bool
        the optional input to specify whether to initialize with some
        previously determined transformation.

    Returns
    -------
    registered_dti: str
        path to the registered DTI.
    transformation: str
        path to the transformation file.
    """
    local_dti = os.path.join(output_dir, os.path.basename(dti))
    if not os.path.isfile(local_dti):
        os.symlink(dti, local_dti)
    cmd = ["dti_rigid_reg", template, local_dti, SMoption, str(sep[0]),
           str(sep[1]), str(sep[2]), str(ftol)]
    if useInTrans:
        cmd.append("1")
    cmd = " ".join(cmd)
    os.system(cmd)
    basename = local_dti.replace(".nii.gz", "")
    registered_dti = "{0}_aff.nii.gz".format(basename)
    transformation = "{0}.aff".format(basename)
    return registered_dti, transformation


def dti_affine_reg(template, dti, output_dir, SMoption="EDS",
                   sep=[4.0, 4.0, 4.0], ftol=0.01, useInTrans=False):
    """ Wraps DTI-TK script dti_affine_reg and affinely align a subject
    DTI volume to a template.

    Parameters
    ----------
    template: str
        the path to the template.
    dti: str
        the path to the DTI volume.
    output_dir: str
        the path to the output directory.
    SMOption: str
        the similarity metric you'd like to use for assessing the quality of
        alignment (Euclidian Distance - EDS,  Deviatoric Distance Squared - DDS
        Geometric Distance Squared - GDS,
        Normalized Mutual Information between tensor components - NMI).
    sep: float array
        the distance between the sample points in the volume for the evaluation
        of image similarity (mm).
    ftol: float
        the minimum amount of change in the cost function as a fraction of the
        previous value at the previous iteration for the registration
        optimization to stop.
    useInTrans: bool
        the optional input to specify whether to initialize with some
        previously determined transformation.

    Returns
    -------
    registered_dti: str
        path to the registered DTI.
    transformation: str
        path to the transformation file.
    """
    local_dti = os.path.join(output_dir, os.path.basename(dti))
    if not os.path.isfile(local_dti):
        os.symlink(dti, local_dti)
    cmd = ["dti_affine_reg", template, local_dti, SMoption, str(sep[0]),
           str(sep[1]), str(sep[2]), str(ftol)]
    if useInTrans:
        cmd.append("1")
    os.system(cmd)
    basename = local_dti.replace(".nii.gz", "")
    registered_dti = "{0}_aff.nii.gz".format(basename)
    transformation = "{0}.aff".format(basename)
    return registered_dti, transformation


def dti_diffeomorphic_reg(template, dti, mask, output_dir, no_of_iter=6,
                          ftol=0.002):
    """ Wraps DTI-TK script dti_diffeomorphic_reg and align a DTI volume
    to a template.

    Parameters
    ----------
    template: str
        the path to the template.
    dti: str
        the path to the DTI volume.
    mask: str
        the path to a binary image that has 0 for background voxels and 1 for
        brain tissue voxels.
    output_dir: str
        the path to the output directory.
    no_of_iter: int
        number of iterations.
    ftol: float
        the minimum amount of change in the cost function.

    Returns
    -------
    registered_dti: str
        path to the registered DTI.
    transformation: str
        path to the deformation field.
    """
    local_dti = os.path.join(output_dir, os.path.basename(dti))
    if not os.path.isfile(local_dti):
        os.symlink(dti, local_dti)
    cmd = ["dti_diffeomorphic_reg", template, local_dti, mask, "1",
           str(no_of_iter), str(ftol)]
    os.system(cmd)
    registered_dti = local_dti.replace(".nii.gz", "_aff_diffeo.nii.gz")
    transformation = local_dti.replace(".nii.gz", "_aff_diffeo.df.nii.gz")
    return registered_dti, transformation


def dti_warp_to_template(dti, template, voxel_dim, output_dir):
    """ Wraps DTI-TK script dti_warp_to_template which combines the
    affine transformation and diffeomorphic displacement field into
    one single displacement field and brings the subject's original data
    from raw space to the space of the template using a single
    interpolation.

    Parameters
    ----------
    dti: str
        the path to the DTI file.
    template: str
        the path to the combined displacement field (affine+deformable
        alignment) file.
    voxel_dim: array (dim 3)
        the array of voxel dimensions.
    output_dir: str
        the path to the output directory.

    Returns
    -------
    registered_dti: str
        path to the registered DTI.
    combined_transformation: str
        path to the transformation combined file.
    """
    local_dti = os.path.join(output_dir, os.path.basename(dti))
    if not os.path.isfile(local_dti):
        os.symlink(dti, local_dti)
    img_dim = "{0} {1} {2}".format(voxel_dim[0], voxel_dim[1], voxel_dim[2])
    cmd = "dti_warp_to_template {0} {1} {2}".format(
        local_dti, template, img_dim)
    os.system(cmd)
    registered_dti = local_dti.replace(".nii.gz", "_diffeo.nii.gz")
    combined_transformation = local_dti.replace(
        ".nii.gz", "_combined.df.nii.gz")
    return registered_dti, combined_transformation


"""
DTI-Tk FA skeleton creation
"""


def generate_FA_map(dti_file, output_fa):
    """ Use DTI-TK TVtool command to generate the FA map of a dti file.

    Parameters
    ----------
    dti_file: str
        path to the dti volume file.
    output_fa: str
        path to the output fa file.

    Returns
    -------
    output_fa_file: str
        path to the output fa file.
    """

    # Generate FA maps
    cmd = ["TVtool", "-in", dti_file, "-fa"]
    cmd = " ".join(cmd)
    os.system(cmd)
    fa_file = dti_file.replace(".nii.gz", "_fa.nii.gz")
    output_fa_file = os.path.join(os.path.dirname(fa_file), output_fa)

    # Rename the FA map to be consistent with the TBSS pipeline
    cmd = ["mv", fa_file, output_fa_file]
    cmd = " ".join(cmd)
    os.system(cmd)

    return output_fa_file


def skeletonize(input_file, output_file, skel_threshold=None,
                distance_map=None, search_rule_mask=None, data_4D=None,
                projected_4Ddata=None, alternative_4Ddata=None,
                alternative_skeleton=None, fsl_sh=DEFAULT_FSL_PATH):
    """ Wraps tbss_skeleton commands and skeletonize FA image.

    Parameters
    ----------
    input_file: str
        path to the input file to skeletonize.
    output_file: str
        path to the output skeleton file.
    skel_threshold: str
        Skeleton threshold. Optional.
    distance_map: str
        Distance map.
    search_rule_mask: str
        search rule mask. Use FSL LowerCingulum_1mm.nii.gz file.
    data_4D: str
        data_4D.
    projected_4Ddata: str
        projected 4D data.
    alternative_4Ddata: str
        alternative 4D data.
    alternative_skeleton: str
        alternative skeleton.
    fsl_sh: str
        path to fsl setup sh file.
    Returns
    -------
    skeleton_file: str
        path to the generated skeleton file.
    """
    cmd = ["tbss_skeleton", "-i", input_file]

    if (skel_threshold is not None or distance_map is not None or
        search_rule_mask is not None or data_4D is not None or
            projected_4Ddata is not None):
        cmd.append("-p")
    if skel_threshold is not None:
        cmd.append(skel_threshold)
    if distance_map is not None:
        cmd.append(distance_map)
    if search_rule_mask is not None:
        cmd.append(search_rule_mask)
    if data_4D is not None:
        cmd.append(data_4D)
    if projected_4Ddata is not None:
        cmd.append(projected_4Ddata)
    if alternative_4Ddata is not None:
        cmd.append("-a")
        cmd.append(alternative_4Ddata)
    if alternative_skeleton is not None:
        cmd.append("-s")
        cmd.append(alternative_skeleton)
    if output_file is not None:
        cmd.append("-o")
        cmd.append(output_file)
    fslprocess = FSLWrapper(shfile=fsl_sh)
    fslprocess(cmd=cmd)

    return output_file


def fslmerge(images, concatenated_output, time=True, x=False, y=False, z=False,
             auto_choose=False, tr=False, fsl_sh=DEFAULT_FSL_PATH):
    """ Wraps fslmerge commands and concatenate different nifti files.

    Parameters
    ----------
    images: list
        list of the images to concatenate.
    concatenated_output: str
        path to output concatenated volume.
    time: bool
        concatenate images in time.
    x: bool
        concatenate images in the x direction.
    y: bool
        concatenate images in the y direction.
    z: bool
        concatenate images in the z direction.
    auto_choose: bool
        single slices -> volume, volumes -> 4D (time series).
    tr: bool
        concatenate images in time and set the output image tr to the final
        option value.
    fsl_sh: str
        path to fsl setup sh file.

    Returns
    -------
    concatenated_output: str
        path to the concatenated images file.
    """
    cmd = ["fslmerge"]
    if time:
        cmd.append("-t")
    elif x:
        cmd.append("-x")
    elif y:
        cmd[1].append("-y")
    elif z:
        cmd[1].append("-z")
    elif auto_choose:
        cmd[1].append("-a")
    elif tr:
        cmd[1].append("-tr")
    else:
        raise ValueError(
            "Please set at least one of fslmerge option to True...")
    cmd.append(concatenated_output)
    for img in images:
        cmd.append(img)
    fslprocess = FSLWrapper(shfile=fsl_sh)
    fslprocess(cmd=cmd)

    return concatenated_output


def get_fa_stack_mask(fa_4D, output, fsl_sh=DEFAULT_FSL_PATH):
    """ Wraps fslmaths command and create a combined binary mask volume from a
   FA 4D data of multiple subjects.

    Parameters
    ----------
    fa_4D: str
        path to the 4D FA data.
    output: str
        path to the combined binary mask volume.
    fsl_sh: str
        path to fsl setup sh file.

    Returns
    -------
    output: str
        path to the combined binary mask volume.
    """
    cmd = ["fslmaths", fa_4D, "-max", "0", "-Tmin", "-bin", output, "-odt",
           "char"]
    fslprocess = FSLWrapper(shfile=fsl_sh)
    fslprocess(cmd=cmd)
    return output


def get_mean_fa(fa_4D, output, fsl_sh=DEFAULT_FSL_PATH):
    """ Wraps fslmaths command and create a mean FA map.

    Parameters
    ----------
    fa_4D: str
        path to the 4D FA data.
    output: str
        path to the mean FA map.
    fsl_sh: str
        path to FSL setup sh file.
    """
    cmd = ["fslmaths", fa_4D, "-Tmean", output]
    fslprocess = FSLWrapper(shfile=fsl_sh)
    fslprocess(cmd=cmd)


"""
TBSS
"""


def tbss_pipeline(tbss_dir, find_best_target=True, use_fmrib58_fa_1mm=False,
                  target_img=None, use_fmrib58_fa_mean_and_skel=False,
                  skel_threshold=0.2, fsl_sh=DEFAULT_FSL_PATH):
    """ Wraps tbss commands to execute tbss pipeline and generate subjects' FA
    skeletons.

    See https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/TBSS/UserGuide for further
    information.

    Steps:
    1) Prepare the FA data in the TBSS working directory in the right
       format.
    2) Register FA images to standard space (nonlinear registration).
    3) Apply transformation to FA images and create and skeletonize the
       mean FA image.
    4) Project all subjects' FA data onto the mean FA skeleton.

    Parameters
    ----------
    tbss_dir: str
        path to tbss output directory.
    find_best_target: bool
        target image used for registration to standard space is the
        "most typical" subject in the study.
    use_fmrib58_fa_1mm: bool
        target image used for registration to standard space is the FMRIB58_FA
        standard-space image given by FSL.
    target_img: str
        target image that will be used for registration to standard space if
        find_best_target and use_fmrib58_fa_1mm parameters are set to False.
    use_fmrib58_fa_mean_and_skel: bool
        use the FMRIB58_FA mean FA image and its derived skeleton, instead of
        the mean of the subjects for tbss_3_postreg.
    skel_threshold: float
        threshold for the mean FA skeleton image thresholding.
    fsl_sh: str
        path to fsl setup sh file.

    Returns
    -------
    fa_dir: str
        path to the subjects corrected FA files.
    orig_dir: str
        path to the copied subjects original FA files.
    all_FA: str
        path to the concatenated subjects FA files in template space.
    mean_FA: str
        path to the subjects' mean FA.
    mean_FA_mask: str
        path to the brain mask of mean_FA.
    mean_FA_skel: str
        path to the skeletonized mean FA.
    all_FA_skeletonized: str
        path to the concatenated subjects skeletonized FA.
    mean_FA_skel_mask: str
        binary skeleton mask.
    mean_FA_skel_mask_dst: str
        distance map created from the skeleton mask.
    thresh_file: str
        text file indicating threshold used.
    """
    os.chdir(tbss_dir)
    print("TBSS preprocessing...")
    fa_dir, orig_dir = tbss_1_preproc(
        tbss_dir=tbss_dir,
        fsl_sh=fsl_sh)

    print("TBSS registration...")
    tbss_2_reg(
        tbss_dir=tbss_dir,
        use_fmrib58_fa_1mm=use_fmrib58_fa_1mm,
        target_img=target_img,
        find_best_target=find_best_target,
        fsl_sh=fsl_sh)

    print("TBSS post-registration...")
    all_FA, mean_FA, mean_FA_mask, mean_FA_skel = tbss_3_postreg(
        tbss_dir=tbss_dir,
        use_fmrib58_fa_mean_and_skel=use_fmrib58_fa_mean_and_skel,
        fsl_sh=fsl_sh)

    print("TBSS pre-stats...")
    (all_FA_skeletonized, mean_FA_skel_mask, mean_FA_skel_mask_dst,
     thresh_file) = tbss_4_prestats(
        tbss_dir=tbss_dir,
        threshold=skel_threshold,
        fsl_sh=fsl_sh)

    return (fa_dir, orig_dir, all_FA, mean_FA, mean_FA_mask, mean_FA_skel,
            all_FA_skeletonized, mean_FA_skel_mask, mean_FA_skel_mask_dst,
            thresh_file)


def tbss_1_preproc(tbss_dir, fsl_sh=DEFAULT_FSL_PATH):
    """ Wraps fsl tbss_1_preproc command to erode the FA images slightly and
    zero the end slices (to remove likely outliers from the diffusion
    tensor fitting).

    For more information, refer to:
    https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/TBSS/UserGuide

    Parameters
    ----------
    tbss_dir: str (required)
        path to tbss root directory.
    fsl_sh: str
        path to fsl setup sh file.

    Returns
    -------
    fa_dir: str
        path to the subjects corrected FA files.
    orig_dir: str
        path to the copied subjects original FA files.
    """
    if not os.path.isdir(tbss_dir):
        os.mkdir(tbss_dir)
    os.chdir(tbss_dir)
    cmd = ["tbss_1_preproc", "*.nii.gz"]
    fslprocess = FSLWrapper(shfile=fsl_sh)
    fslprocess(cmd=cmd)
    fa_dir = os.path.join(tbss_dir, "FA")
    orig_dir = os.path.join(tbss_dir, "origdata")
    if not os.path.isdir(fa_dir):
        raise ValueError(
            "tbss_1_preproc did not create FA dir : {0}...".format(fa_dir))
    if not os.path.isdir(orig_dir):
        raise ValueError(
            "tbss_1_preproc did not create orig dir : {0}...".format(orig_dir))
    return fa_dir, orig_dir


def fsl_reg(fa_basename, tbss_dir, fsl_sh):
    """ Run the FSL registration step.

    Wrapping around the 'fsl_reg' command.

    Parameters
    ----------
    fa_basename: str
        the FA file base name.
    tbss_dir: str
        path to tbss root directory.
    fsl_sh: str
        path to fsl setup sh file.
    """
    cmd = ["fsl_reg", fa_basename, "target", fa_basename + "_to_target", "-e",
           "-FA"]
    print("Executing: " + " ".join(cmd))
    fslprocess = FSLWrapper(shfile=fsl_sh)
    fslprocess(cmd=cmd, cwdir=os.path.join(tbss_dir, "FA"))


def tbss_2_reg(tbss_dir, use_fmrib58_fa_1mm=False, target_img=None,
               find_best_target=True, nb_cpus=None,
               fsl_sh=DEFAULT_FSL_PATH):
    """ Wraps fsl tbss_2_reg command to non-linearly register the FA images
    to a 1x1x1mm standard space or a template image or the best target from
    all FA images.

    For more information, refer to:
    https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/TBSS/UserGuide

    Parameters
    ----------
    tbss_dir: str (required)
        path to tbss root directory.
    use_fmrib58_fa_1mm: bool (optional, default True)
        use FMRIB58_FA_1mm as target for nonlinear registrations (recommended).
    target_img: str (optional, default None)
        path to a target image to use for nonlinear registration.
    find_best_target: bool (default False)
        option to find best target from all FA images.
    nb_cpus: int, default None
        the number of cpus to use, default all - 1.
    fsl_sh: str
        path to fsl setup sh file.
    """
    if not (os.getcwd() == tbss_dir):
        os.chdir(tbss_dir)
    cmd = ["tbss_2_reg"]
    if use_fmrib58_fa_1mm:
        # cmd.append("-T")
        process = FSLWrapper([], shfile=fsl_sh)
        shutil.copy2(
            os.path.join(process.environment["FSLDIR"], "data", "standard",
                         "FMRIB58_FA_1mm.nii.gz"),
            os.path.join(tbss_dir, "FA", "target.nii.gz"))
    elif target_img is not None:
        # cmd.extend(["-t", target_img])
        shutil.copy2(target_img, os.path.join(tbss_dir, "FA", "target.nii.gz"))
    elif find_best_target:
        cmd.append("-n")
        fslprocess = FSLWrapper(shfile=fsl_sh)
        fslprocess(cmd=cmd)
        return
    else:
        raise ValueError(
            "Please enter valid parameters for function tbss_2_reg.")
    if nb_cpus is None:
        nb_cpus = multiprocessing.cpu_count() - 1
    fa_basenames = glob.glob1(os.path.join(tbss_dir, "FA"), "*_FA.nii.gz")
    fa_basenames = [name.split(".")[0] for name in fa_basenames]
    Parallel(n_jobs=nb_cpus)(delayed(fsl_reg)(name, tbss_dir, fsl_sh)
                             for name in fa_basenames)


def tbss_3_postreg(tbss_dir, use_fmrib58_fa_mean_and_skel=True,
                   fsl_sh=DEFAULT_FSL_PATH):
    """ Wraps fsl tbss_3_postreg command to apply the nonlinear transforms
    found in the previous stage to all subjects to bring them into
    standard space. Merge results into a single 4D image.
    Compute a mean FA image and skeletonize it.

    For more information, refer to:
    https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/TBSS/UserGuide

    Parameters
    ----------
    tbss_dir: str (required)
        path to tbss root directory.
    use_fmrib58_fa_mean_and_skel: bool (optional, default True)
        use the FMRIB58_FA mean FA image and its derived skeleton, instead of
        the mean of the subjects.
    fsl_sh: str
        path to fsl setup sh file.

    Returns
    -------
    all_FA: str
        path to the concatenated subjects FA files in template space.
    mean_FA: str
        path to the subjects' mean FA.
    mean_FA_mask: str
        path to the brain mask of mean_FA.
    mean_FA_skel: str
        path to the skeletonized mean FA.
    """
    if not os.getcwd() == tbss_dir:
        os.chdir(tbss_dir)
    cmd = ["tbss_3_postreg"]
    if use_fmrib58_fa_mean_and_skel:
        cmd.append("-T")
    else:
        cmd.append("-S")
    fslprocess = FSLWrapper(shfile=fsl_sh)
    fslprocess(cmd=cmd)

    # Check that output files have been correctly created.
    all_FA = os.path.join(tbss_dir, "stats", "all_FA.nii.gz")
    mean_FA = os.path.join(tbss_dir, "stats", "mean_FA.nii.gz")
    mean_FA_mask = os.path.join(tbss_dir, "stats", "mean_FA_mask.nii.gz")
    mean_FA_skel = os.path.join(tbss_dir, "stats", "mean_FA_skeleton.nii.gz")
    output_files = [all_FA, mean_FA, mean_FA_mask, mean_FA_skel]
    for out_file in output_files:
        if not os.path.isfile(out_file):
            raise ValueError(
                "tbss_3_postreg outputs : {0} does not exist! FSL error: "
                "{1}".format(out_file, fslprocess.stderr))
    return all_FA, mean_FA, mean_FA_mask, mean_FA_skel


def tbss_4_prestats(tbss_dir, threshold=0.2, fsl_sh=DEFAULT_FSL_PATH):
    """ Wraps fsl tbss_4_prestats command to thresholds the mean FA skeleton
    image at the chosen threshold, create a distance map, and project the
    FA data onto the mean FA skeleton.
    To be used before any voxelwise cross-subject stats.

    For more information, refer to:
    https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/TBSS/UserGuide

    Parameters
    ----------
    tbss_dir: str (required)
        path to tbss root directory.
    threshold: float (required, default 0.2)
    fsl_sh: str
        path to fsl setup sh file.

    Returns
    -------
    all_FA_skeletonized: str
        path to the concatenated subjects skeletonized FA.
    mean_FA_skel_mask: str
        binary skeleton mask.
    mean_FA_skel_mask_dst: str
        distance map created from the skeleton mask.
    thresh_file: str
        text file indicating threshold used.
    """
    if not os.getcwd() == tbss_dir:
        os.chdir(tbss_dir)
    cmd = ["tbss_4_prestats", str(threshold)]
    fslprocess = FSLWrapper(shfile=fsl_sh)
    fslprocess(cmd=cmd)

    # Check that output files have been correctly created.
    all_FA_skeletonized = os.path.join(
        tbss_dir, "stats", "all_FA_skeletonised.nii.gz")
    mean_FA_skel_mask = os.path.join(
        tbss_dir, "stats", "mean_FA_skeleton_mask.nii.gz")
    mean_FA_skel_mask_dst = os.path.join(
        tbss_dir, "stats", "mean_FA_skeleton_mask_dst.nii.gz")
    thresh_file = os.path.join(tbss_dir, "stats", "thresh.txt")
    return (all_FA_skeletonized, mean_FA_skel_mask, mean_FA_skel_mask_dst,
            thresh_file)
