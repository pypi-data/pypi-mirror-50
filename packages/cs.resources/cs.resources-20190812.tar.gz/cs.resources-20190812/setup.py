#!/usr/bin/env python
from setuptools import setup
setup(
  name = 'cs.resources',
  description = 'resourcing related classes and functions',
  author = 'Cameron Simpson',
  author_email = 'cs@cskk.id.au',
  version = '20190812',
  url = 'https://bitbucket.org/cameron_simpson/css/commits/all',
  classifiers = ['Programming Language :: Python', 'Programming Language :: Python :: 2', 'Programming Language :: Python :: 3', 'Development Status :: 4 - Beta', 'Intended Audience :: Developers', 'Operating System :: OS Independent', 'Topic :: Software Development :: Libraries :: Python Modules', 'License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)'],
  include_package_data = True,
  install_requires = ['cs.logutils', 'cs.obj', 'cs.py.func', 'cs.py.stack'],
  keywords = ['python2', 'python3'],
  license = 'GNU General Public License v3 or later (GPLv3+)',
  long_description = '*Release 20190812*:\nMultiOpenMixin: no longer subclass cs.obj.O.\nMultiOpenMixin: remove `lock` param support, the mixin has its own lock.\nMultiOpen: drop `lock` param support, no longer used by MultiOpenMixin.\nMultiOpenMixin: do finalise inside the lock for the same reason as shutdown (competition with open/startup).\nMultiOpenMixin.close: new `unopened_ok=False` parameter intended for callback closes which might fire even if the initial open does not occur.\n\nResource management classes and functions.\n\n## Class `ClosedError`\n\nMRO: `builtins.Exception`, `builtins.BaseException`  \nException for operations invalid when something is closed.\n\n## Class `MultiOpen`\n\nMRO: `MultiOpenMixin`  \nContext manager class that manages a single open/close object\nusing a MultiOpenMixin.\n\n### Method `MultiOpen.__init__(self, openable, finalise_later=False)`\n\nInitialise: save the `openable` and call the MultiOpenMixin initialiser.\n\n## Class `MultiOpenMixin`\n\nA mixin to count open and close calls, and to call .startup\non the first .open and to call .shutdown on the last .close.\n\nRecommended subclass implementations do as little as possible\nduring __init__, and do almost all setup during startup so\nthat the class may perform multiple startup/shutdown iterations.\n\nIf used as a context manager calls open()/close() from\n__enter__() and __exit__().\n\nMultithread safe.\n\nThis mixin defines ._lock = RLock(); subclasses need not\nbother, but may supply their own lock.\n\nClasses using this mixin need to define .startup and .shutdown.\n\n### Method `MultiOpenMixin.__init__(self, finalise_later=False)`\n\nInitialise the MultiOpenMixin state.\n\nParameters:\n* `finalise_later`: do not notify the finalisation Condition on\n  shutdown, require a separate call to .finalise().\n  This is mode is useful for objects such as queues where\n  the final close prevents further .put calls, but users\n  calling .join may need to wait for all the queued items\n  to be processed.\n\nTODO:\n* `subopens`: if true (default false) then .open will return\n  a proxy object with its own .closed attribute set by the\n  proxy\'s .close.\n\n## Function `not_closed(func)`\n\nDecorator to wrap methods of objects with a .closed property\nwhich should raise when self.closed.\n\n## Class `Pool`\n\nMRO: `cs.obj.O`  \nA generic pool of objects on the premise that reuse is cheaper than recreation.\n\nAll the pool objects must be suitable for use, so the\n`new_object` callable will typically be a closure.\nFor example, here is the __init__ for a per-thread AWS Bucket using a\ndistinct Session:\n\n    def __init__(self, bucket_name):\n        Pool.__init__(self, lambda: boto3.session.Session().resource(\'s3\').Bucket(bucket_name)\n\n### Method `Pool.__init__(self, new_object, max_size=None, lock=None)`\n\nInitialise the Pool with creator `new_object` and maximum size `max_size`.\n\nParameters:\n* `new_object` is a callable which returns a new object for the Pool.\n* `max_size`: The maximum size of the pool of available objects saved for reuse.\n    If omitted or `None`, defaults to 4.\n    If 0, no upper limit is applied.\n* `lock`: optional shared Lock; if omitted or `None` a new Lock is allocated\n\n## Class `RunState`\n\nA class to track a running task whose cancellation may be requested.\n\nIts purpose is twofold, to provide easily queriable state\naround tasks which can start and stop, and to provide control\nmethods to pronounce that a task has started (`.start`),\nshould stop (`.cancel`)\nand has stopped (`.stop`).\n\nA `RunState` can be used a a context manager, with the enter\nand exit methods calling `.start` and `.stop` respectively.\nNote that if the suite raises an exception\nthen the exit method also calls `.cancel` before the call to `.stop`.\n\nMonitor or daemon processes can poll the `RunState` to see when\nthey should terminate, and may also manage the overall state\neasily using a context manager.\nExample:\n\n    def monitor(self):\n        with self.runstate:\n            while not self.runstate.cancelled:\n                ... main loop body here ...\n\nA `RunState` has three main methods:\n* `.start()`: set `.running` and clear `.cancelled`\n* `.cancel()`: set `.cancelled`\n* `.stop()`: clear `.running`\n\nA `RunState` has the following properties:\n* `cancelled`: true if `.cancel` has been called.\n* `running`: true if the task is running.\n  Further, assigning a true value to it also sets `.start_time` to now.\n  Assigning a false value to it also sets `.stop_time` to now.\n* `start_time`: the time `.running` was last set to true.\n* `stop_time`: the time `.running` was last set to false.\n* `run_time`: `max(0,.stop_time-.start_time)`\n* `stopped`: true if the task is not running.\n* `stopping`: true if the task is running but has been cancelled.\n* `notify_start`: a set of callables called with the `RunState` instance\n  to be called whenever `.running` becomes true.\n* `notify_end`: a set of callables called with the `RunState` instance\n  to be called whenever `.running` becomes false.\n* `notify_cancel`: a set of callables called with the `RunState` instance\n  to be called whenever `.cancel` is called.\n\n## Class `RunStateMixin`\n\nMixin to provide convenient access to a `RunState`.\n\nProvides: `.runstate`, `.cancelled`, `.running`, `.stopping`, `.stopped`.\n\n### Method `RunStateMixin.__init__(self, runstate=None)`\n\nInitialise the `RunStateMixin`; sets the `.runstate` attribute.\n\n`runstate`: `RunState` instance or name.\nIf a `str`, a new `RunState` with that name is allocated.\n\n\n\n# Release Log\n\n*Release 20190812*:\nMultiOpenMixin: no longer subclass cs.obj.O.\nMultiOpenMixin: remove `lock` param support, the mixin has its own lock.\nMultiOpen: drop `lock` param support, no longer used by MultiOpenMixin.\nMultiOpenMixin: do finalise inside the lock for the same reason as shutdown (competition with open/startup).\nMultiOpenMixin.close: new `unopened_ok=False` parameter intended for callback closes which might fire even if the initial open does not occur.\n\n*Release 20190617*:\nRunState.__exit__: if an exception was raised call .canel() before calling .stop().\n\n*Release 20190103*:\nBugfixes for context managers.\nMultiOpenMixin fixes and changes.\nRunState improvements.\n\n*Release 20171024*:\nbugfix MultiOpenMixin finalise logic and other small logic fixes and checs\nnew class RunState for tracking or controlling a running task\n\n*Release 20160828*:\nUse "install_requires" instead of "requires" in DISTINFO.\n\n*Release 20160827*:\nBREAKING CHANGE: rename NestingOpenCloseMixin to MultiOpenMixin.\nNew Pool class for generic object reuse.\nAssorted minor improvements.\n\n*Release 20150115*:\nFirst PyPI release.',
  long_description_content_type = 'text/markdown',
  package_dir = {'': 'lib/python'},
  py_modules = ['cs.resources'],
)
