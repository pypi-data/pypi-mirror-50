# auto generated by update_py.py
import argparse
import json
import multiprocessing
import os
import signal
import subprocess
import sys
import traceback

from linker import __version__ as linker_version

from . import __version__ as trader_version
from .gun_helpers import (CONFIG_DEFAULT_PATH, CONFIG_FOLDER, FIST_FAIL_MARK,
                          FIST_READY_MARK)

LOGO_PRINT = '''
  _                 _                 _ _       _
 | |_ _ __ __ _  __| | ___ _ __ ___  | (_)_ __ | | __
 | __| '__/ _` |/ _` |/ _ \ '__/ __| | | | '_ \| |/ /
 | |_| | | (_| | (_| |  __/ |  \__ \_| | | | | |   <
  \__|_|  \__,_|\__,_|\___|_|  |___(_)_|_|_| |_|_|\_\

    ----------------
    info@puyuan.tech
    trader: {}
    linker: {}
    ----------------
'''.format(trader_version, linker_version)


class ConsoleEntrance(object):

    FIST_TYPES = ['master', 'tg', 'mg', 'tr', 'mr', 'oms', 'rms', 'bs', 'algo', 'rr']  # ALL fist type supported

    HELP_MSG = '''
----------------------
gun <command> [<args>]

The most commonly used boxing commands are:
    help            show help info
    ctl             control panel for services
    version         get version
    config          config related ops
    status          show master status
    start           start process in background, foreground exit when inited
    stop            stop with a fist_name, 'gun stop \*' to stop all fists except master
    run             run process in foreground

    supported fist_type: {}
----------------------
'''.format(FIST_TYPES)

    def __init__(self):
        pass

    def parse_and_execute(self):
        entry_parser = argparse.ArgumentParser(description='Trader Command Tool', usage=self.HELP_MSG)
        entry_parser.add_argument('command', help='Subcommand to run')
        # parse_args defaults to [1:] for args, but you need to
        # exclude the rest of the args too, or validation will fail
        args = entry_parser.parse_args(sys.argv[1:2])
        if not hasattr(self, args.command):
            print('Unrecognized command: ' + args.command + '\n')
            entry_parser.print_help()
            exit(1)

        self.main_parser = argparse.ArgumentParser(description='gun run')
        self.main_parser.add_argument('-t', '--proc_type', choices=self.FIST_TYPES, help='process type')
        self.main_parser.add_argument('-f', '--fist_name', help='fist name')
        self.main_parser.add_argument('-g', '--gateway_name', help='gateway name')
        self.main_parser.add_argument('-a', '--acc_tag', help='account tag')
        self.main_parser.add_argument('-r', '--router_name', help='router name')
        self.main_parser.add_argument('-s', '--secondary_router_name', help='market router for mock')
        self.main_parser.add_argument('-p', '--package_name', help='package name')
        self.main_parser.add_argument('-d', '--db', action='store_true', help='enable db module')
        # use dispatch pattern to invoke method with same name
        getattr(self, args.command)()

    def help(self):
        print(self.HELP_MSG)

    def ctl(self):
        os.system("/usr/bin/supervisorctl -c {}/supervisor/supervisord.conf".format(CONFIG_FOLDER))

    def version(self):
        print(LOGO_PRINT)

    def status(self):
        os.system("linker_status")

    def stop(self):
        fist_name = sys.argv[2]
        # create a fist and call related function
        from trader.gun_helpers import GunClientHelper
        helper = GunClientHelper('__killer', CONFIG_DEFAULT_PATH)
        helper.stop(fist_name)

    def join(self):
        fist_name = sys.argv[2]
        from trader.gun_helpers import GunClientHelper
        helper = GunClientHelper('__joiner', CONFIG_DEFAULT_PATH)
        helper.join(fist_name, join_wait_seconds=2)

    def run(self):
        assert len(sys.argv) > 2, 'must specify -f --fist_type'
        fist_type = sys.argv[2]
        args = None
        if fist_type not in self.FIST_TYPES:
            if fist_type.startswith('-'):
                args = self.main_parser.parse_args(sys.argv[2:])
                fist_type = args.proc_type
        if fist_type not in self.FIST_TYPES:
            print(FIST_FAIL_MARK)
            self.main_parser.error('\n[UNSUPPORTED_TYPE] {} is not in supported list: {}'.format(fist_type, self.FIST_TYPES))
            return
        else:
            if args is None:
                args = self.main_parser.parse_args(sys.argv[3:])
            p = multiprocessing.Process(target=self._run_process, args=[fist_type, args])
            p.daemon = True
            p.start()
            p.join()

    def start(self):
        args = list(sys.argv)
        args[1] = 'run'
        cmd = ' '.join(args)
        popen = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
        while popen.poll() is None:
            line = popen.stdout.readline().decode()
            if len(line) > 0:
                sys.stdout.write(line)
            exit_code = 0 if FIST_READY_MARK in line else (1 if FIST_FAIL_MARK in line else -1)
            if exit_code != -1:
                exit(exit_code)

    def _run_process(self, fist_type, args):

        if fist_type in ['tg', 'mg']:
            if None in [args.gateway_name, args.acc_tag, args.router_name]:
                print(FIST_FAIL_MARK)
                self.main_parser.error('\n[MISSING_ARGS] {} also requires -g -a -r'.format(fist_type))
                return
            from trader.gun_helpers import Gateway
            try:
                Gateway(fist_type, args.gateway_name, args.acc_tag, args.router_name, args.secondary_router_name).run()
            except:
                print(FIST_FAIL_MARK)

        elif fist_type in ['tr', 'mr']:
            from trader.gun_helpers import Router
            Router(fist_type, args.fist_name).run()

        elif fist_type in ['oms']:
            from trader.gun_helpers import OrderService
            try:
                OrderService(args.fist_name, args.router_name, args.db).run()
            except:
                print(FIST_FAIL_MARK)

        elif fist_type in ['rms']:
            from trader.gun_helpers import RiskManagementService
            try:
                RiskManagementService(fist_name=args.fist_name, router1=args.router_name).run()
            except:
                print(FIST_FAIL_MARK)

        elif fist_type in ['bs']:
            from trader.gun_helpers import BasketServer
            try:
                BasketServer(fist_name=args.fist_name, trade_router=args.router_name).run()
            except:
                print(FIST_FAIL_MARK)

        elif fist_type in ['algo']:
            from trader.gun_helpers import AlgoServer
            try:
                if args.router_name:
                    trade_router, market_router = args.router_name.split('/')
                else:
                    trade_router, market_router = None, None
                AlgoServer(algo_type=args.fist_name, trade_router=trade_router, market_router=market_router).run()
            except Exception as e:
                print('[error] {} (traceback){}'.format(e, traceback.format_exc()))
                print(FIST_FAIL_MARK)

        elif fist_type in ['rr']:
            from trader.gun_helpers import GunRecorder
            if None in [args.fist_name, args.router_name]:
                print(FIST_FAIL_MARK)
                self.main_parser.error('\n[MISSING_ARGS] {} also requires -f -r'.format(fist_type))
                return
            router_names = args.router_name.split('/')
            try:
                GunRecorder(args.fist_name, router_names).run()
            except:
                print(FIST_FAIL_MARK)

        elif fist_type in ['master']:
            import liblinker
            master = liblinker.Master()
            master.start()
            print(FIST_READY_MARK)
            master.join()

        else:
            print(FIST_FAIL_MARK)
            raise NotImplementedError('process type "{}" not implemented yet'.format(fist_type))

    def config(self):
        from trader.gun_helpers import ConfigHelper

        parser = argparse.ArgumentParser(description="gun update_config")
        me_group = parser.add_mutually_exclusive_group(required=True)
        me_group.add_argument('-u', '--upgrade', action="store_true", help='to upgrade config file')
        me_group.add_argument('-c', '--check', action='store_true', help='to check config file')
        parser.add_argument('-d', '--config_dir', type=str, default=CONFIG_FOLDER, help='directory where config file was stored')
        args = parser.parse_args(sys.argv[2:])

        config_helper = ConfigHelper(args.config_dir)
        if args.upgrade:
            # backup config file
            config_helper.backup_config()
            # upgrade config file
            config_helper.update_config()
            print('current_version: {}'.format(config_helper.config_version))
            config_helper.dump_config()
            print("finished updating config")

        elif args.check:
            print('config path: {}'.format(config_helper.config_path))
            config_helper.check_version()

        else:
            raise NotImplementedError()
