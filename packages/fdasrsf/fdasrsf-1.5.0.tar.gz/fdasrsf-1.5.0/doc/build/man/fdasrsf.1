.\" Man page generated from reStructuredText.
.
.TH "FDASRSF" "1" "Aug 08, 2019" "1.5" "fdasrsf"
.SH NAME
fdasrsf \- fdasrsf Documentation
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.sp
A python package for functional data analysis using the square root
slope framework and curves using the square root velocity framework
which performs pair\-wise and group\-wise alignment as well as modeling
using functional component analysis and regression.
.SH FUNCTIONAL ALIGNMENT
.sp
Group\-wise function alignment using SRSF framework and Dynamic Programming
.sp
moduleauthor:: Derek Tucker <\fI\%jdtuck@sandia.gov\fP>
.INDENT 0.0
.TP
.B time_warping.align_fPCA(f, time, num_comp=3, showplot=True, smoothdata=False)
aligns a collection of functions while extracting principal components.
The functions are aligned to the principal components
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBf\fP (\fInp.ndarray\fP) \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBtime\fP (\fInp.ndarray\fP) \-\- vector of size M describing the sample points
.IP \(bu 2
\fBnum_comp\fP \-\- number of fPCA components
.IP \(bu 2
\fBshowplot\fP \-\- Shows plots of results using matplotlib (default = T)
.IP \(bu 2
\fBsmooth_data\fP (\fI\%bool\fP) \-\- Smooth the data using a box filter (default = F)
.IP \(bu 2
\fBsparam\fP (\fIdouble\fP) \-\- Number of times to run box filter (default = 25)
.UNINDENT
.TP
.B Return type
tuple of numpy array
.TP
.B Return fn
aligned functions \- numpy ndarray of shape (M,N) of N
functions with M samples
.TP
.B Return qn
aligned srvfs \- similar structure to fn
.TP
.B Return q0
original srvf \- similar structure to fn
.TP
.B Return mqn
srvf mean or median \- vector of length M
.TP
.B Return gam
warping functions \- similar structure to fn
.TP
.B Return q_pca
srsf principal directions
.TP
.B Return f_pca
functional principal directions
.TP
.B Return latent
latent values
.TP
.B Return coef
coefficients
.TP
.B Return U
eigenvectors
.TP
.B Return orig_var
Original Variance of Functions
.TP
.B Return amp_var
Amplitude Variance
.TP
.B Return phase_var
Phase Variance
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B time_warping.align_fPLS(f, g, time, comps=3, showplot=True, smoothdata=False, delta=0.01, max_itr=100)
This function aligns a collection of functions while performing
principal least squares
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBf\fP (\fInp.ndarray\fP) \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBg\fP (\fInp.ndarray\fP) \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBtime\fP (\fInp.ndarray\fP) \-\- vector of size M describing the sample points
.IP \(bu 2
\fBcomps\fP \-\- number of fPLS components
.IP \(bu 2
\fBshowplot\fP \-\- Shows plots of results using matplotlib (default = T)
.IP \(bu 2
\fBsmooth_data\fP (\fI\%bool\fP) \-\- Smooth the data using a box filter (default = F)
.IP \(bu 2
\fBdelta\fP \-\- gradient step size
.IP \(bu 2
\fBmax_itr\fP \-\- maximum number of iterations
.UNINDENT
.TP
.B Return type
tuple of numpy array
.TP
.B Return fn
aligned functions \- numpy ndarray of shape (M,N) of N
.UNINDENT
.sp
functions with M samples
:return gn: aligned functions \- numpy ndarray of shape (M,N) of N
functions with M samples
:return qfn: aligned srvfs \- similar structure to fn
:return qgn: aligned srvfs \- similar structure to fn
:return qf0: original srvf \- similar structure to fn
:return qg0: original srvf \- similar structure to fn
:return gam: warping functions \- similar structure to fn
:return wqf: srsf principal weight functions
:return wqg: srsf principal weight functions
:return wf: srsf principal weight functions
:return wg: srsf principal weight functions
:return cost: cost function value
.UNINDENT
.INDENT 0.0
.TP
.B time_warping.srsf_align(f, time, method=\(aqmean\(aq, omethod=\(aqDP\(aq, showplot=True, smoothdata=False, parallel=False, lam=0.0)
This function aligns a collection of functions using the elastic
square\-root slope (srsf) framework.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBf\fP \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBtime\fP \-\- vector of size M describing the sample points
.IP \(bu 2
\fBmethod\fP \-\- (string) warp calculate Karcher Mean or Median
.UNINDENT
.UNINDENT
.sp
(options = "mean" or "median") (default="mean")
:param omethod: optimization method (DP, DP2, RBFGS) (default = DP)
:param showplot: Shows plots of results using matplotlib (default = T)
:param smoothdata: Smooth the data using a box filter (default = F)
:param parallel: run in parallel (default = F)
:param lam: controls the elasticity (default = 0)
:type lam: double
:type smoothdata: bool
:type f: np.ndarray
:type time: np.ndarray
.INDENT 7.0
.TP
.B Return type
tuple of numpy array
.TP
.B Return fn
aligned functions \- numpy ndarray of shape (M,N) of N
.UNINDENT
.sp
functions with M samples
:return qn: aligned srvfs \- similar structure to fn
:return q0: original srvf \- similar structure to fn
:return fmean: function mean or median \- vector of length M
:return mqn: srvf mean or median \- vector of length M
:return gam: warping functions \- similar structure to fn
:return orig_var: Original Variance of Functions
:return amp_var: Amplitude Variance
:return phase_var: Phase Variance
.sp
Examples
>>> import tables
>>> fun=tables.open_file("../Data/simu_data.h5")
>>> f = fun.root.f[:]
>>> f = f.transpose()
>>> time = fun.root.time[:]
>>> out = srsf_align(f,time)
.UNINDENT
.INDENT 0.0
.TP
.B time_warping.srsf_align_pair(f, g, time, method=\(aqmean\(aq, showplot=True, smoothdata=False, lam=0.0)
This function aligns a collection of functions using the elastic square\-
root slope (srsf) framework.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBf\fP (\fInp.ndarray\fP) \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBg\fP \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBtime\fP (\fInp.ndarray\fP) \-\- vector of size M describing the sample points
.IP \(bu 2
\fBmethod\fP \-\- (string) warp calculate Karcher Mean or Median (options =
"mean" or "median") (default="mean")
.IP \(bu 2
\fBshowplot\fP \-\- Shows plots of results using matplotlib (default = T)
.IP \(bu 2
\fBsmoothdata\fP (\fI\%bool\fP) \-\- Smooth the data using a box filter (default = F)
.IP \(bu 2
\fBlam\fP (\fIdouble\fP) \-\- controls the elasticity (default = 0)
.UNINDENT
.TP
.B Return type
tuple of numpy array
.TP
.B Return fn
aligned functions \- numpy ndarray of shape (M,N) of N
functions with M samples
.TP
.B Return gn
aligned functions \- numpy ndarray of shape (M,N) of N
functions with M samples
.TP
.B Return qfn
aligned srvfs \- similar structure to fn
.TP
.B Return qgn
aligned srvfs \- similar structure to fn
.TP
.B Return qf0
original srvf \- similar structure to fn
.TP
.B Return qg0
original srvf \- similar structure to fn
.TP
.B Return fmean
f function mean or median \- vector of length N
.TP
.B Return gmean
g function mean or median \- vector of length N
.TP
.B Return mqfn
srvf mean or median \- vector of length N
.TP
.B Return mqgn
srvf mean or median \- vector of length N
.TP
.B Return gam
warping functions \- similar structure to fn
.UNINDENT
.UNINDENT
.SH FUNCTIONAL PRINCIPAL COMPONENT ANALYSIS
.sp
Vertical and Horizontal Functional Principal Component Analysis using SRSF
.sp
moduleauthor:: Derek Tucker <\fI\%jdtuck@sandia.gov\fP>
.INDENT 0.0
.TP
.B fPCA.horizfPCA(gam, time, no=2, showplot=True)
This function calculates horizontal functional principal component analysis on aligned data
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBgam\fP \-\- numpy ndarray of shape (M,N) of N warping functions
.IP \(bu 2
\fBtime\fP \-\- vector of size M describing the sample points
.IP \(bu 2
\fBno\fP (\fI\%int\fP) \-\- number of components to extract (default = 2)
.IP \(bu 2
\fBshowplot\fP (\fI\%bool\fP) \-\- Shows plots of results using matplotlib (default = T)
.UNINDENT
.TP
.B Return type
tuple of numpy ndarray
.TP
.B Return q_pca
srsf principal directions
.TP
.B Return f_pca
functional principal directions
.TP
.B Return latent
latent values
.TP
.B Return coef
coefficients
.TP
.B Return U
eigenvectors
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B fPCA.jointfPCA(fn, time, qn, q0, gam, no=2, showplot=True)
This function calculates joint functional principal component analysis
on aligned data
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBfn\fP \-\- numpy ndarray of shape (M,N) of N aligned functions with M
samples
.IP \(bu 2
\fBtime\fP \-\- vector of size N describing the sample points
.IP \(bu 2
\fBqn\fP \-\- numpy ndarray of shape (M,N) of N aligned SRSF with M samples
.IP \(bu 2
\fBno\fP (\fI\%int\fP) \-\- number of components to extract (default = 2)
.IP \(bu 2
\fBshowplot\fP (\fI\%bool\fP) \-\- Shows plots of results using matplotlib (default = T)
.UNINDENT
.TP
.B Return type
tuple of numpy ndarray
.TP
.B Return q_pca
srsf principal directions
.TP
.B Return f_pca
functional principal directions
.TP
.B Return latent
latent values
.TP
.B Return coef
coefficients
.TP
.B Return U
eigenvectors
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B fPCA.vertfPCA(fn, time, qn, no=2, showplot=True)
This function calculates vertical functional principal component analysis
on aligned data
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBfn\fP \-\- numpy ndarray of shape (M,N) of N aligned functions with M
samples
.IP \(bu 2
\fBtime\fP \-\- vector of size N describing the sample points
.IP \(bu 2
\fBqn\fP \-\- numpy ndarray of shape (M,N) of N aligned SRSF with M samples
.IP \(bu 2
\fBno\fP (\fI\%int\fP) \-\- number of components to extract (default = 2)
.IP \(bu 2
\fBshowplot\fP (\fI\%bool\fP) \-\- Shows plots of results using matplotlib (default = T)
.UNINDENT
.TP
.B Return type
tuple of numpy ndarray
.TP
.B Return q_pca
srsf principal directions
.TP
.B Return f_pca
functional principal directions
.TP
.B Return latent
latent values
.TP
.B Return coef
coefficients
.TP
.B Return U
eigenvectors
.UNINDENT
.UNINDENT
.SH ELASTIC FUNCTIONAL BOXPLOTS
.sp
Elastic Functional Boxplots
.sp
moduleauthor:: Derek Tucker <\fI\%jdtuck@sandia.gov\fP>
.INDENT 0.0
.TP
.B boxplots.ampbox(ft, f_median, qt, q_median, time, alpha=0.05, k_a=1)
This function constructs the amplitude boxplot using the elastic
square\-root slope (srsf) framework.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBft\fP \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBf_median\fP \-\- vector of size M describing the median
.IP \(bu 2
\fBqt\fP \-\- numpy ndarray of shape (M,N) of N srsf functions with M samples
.IP \(bu 2
\fBq_median\fP \-\- vector of size M describing the srsf median
.IP \(bu 2
\fBtime\fP \-\- vector of size M describing the time
.IP \(bu 2
\fBalpha\fP \-\- quantile value (e.g.,=.05, i.e., 95%)
.IP \(bu 2
\fBk_a\fP \-\- scalar for outlier cutoff (e.g.,=1)
.UNINDENT
.TP
.B Return type
tuple of numpy array
.TP
.B Return fn
aligned functions \- numpy ndarray of shape (M,N) of N
.UNINDENT
.sp
functions with M samples
:return Q1: First quartile
:return Q3: Second quartile
:return Q1a: First quantile based on alpha
:return Q3a: Second quantile based on alpha
:return minn: minimum extreme function
:return maxx: maximum extreme function
:return outlier_index: indexes of outlier functions
:return f_median: median function
:return q_median: median srsf
:return plt: surface plot mesh
.UNINDENT
.INDENT 0.0
.TP
.B boxplots.phbox(gam, time, alpha=0.05, k_a=1)
This function constructs phase boxplot for functional data using the elastic
square\-root slope (srsf) framework.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBgam\fP \-\- numpy ndarray of shape (M,N) of N warping functions with M samples
.IP \(bu 2
\fBalpha\fP \-\- quantile value (e.g.,=.05, i.e., 95%)
.IP \(bu 2
\fBk_a\fP \-\- scalar for outlier cutoff (e.g.,=1)
.UNINDENT
.TP
.B Return type
tuple of numpy array
.TP
.B Return fn
aligned functions \- numpy ndarray of shape (M,N) of N
.UNINDENT
.sp
functions with M samples
:return Q1: First quartile
:return Q3: Second quartile
:return Q1a: First quantile based on alpha
:return Q3a: Second quantile based on alpha
:return minn: minimum extreme function
:return maxx: maximum extreme function
:return outlier_index: indexes of outlier functions
:return median_x: median warping function
:return psi_median: median srsf of warping function
:return plt: surface plot mesh
.UNINDENT
.SH GAUSSIAN GENERATIVE MODELS
.sp
Gaussian Model of functional data
.sp
moduleauthor:: Derek Tucker <\fI\%jdtuck@sandia.gov\fP>
.INDENT 0.0
.TP
.B gauss_model.gauss_model(fn, time, qn, gam, n=1, sort_samples=False)
This function models the functional data using a Gaussian model
extracted from the principal components of the srvfs
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBfn\fP (\fInp.ndarray\fP) \-\- numpy ndarray of shape (M,N) of N aligned functions with
M samples
.IP \(bu 2
\fBtime\fP (\fInp.ndarray\fP) \-\- vector of size M describing the sample points
.IP \(bu 2
\fBqn\fP (\fInp.ndarray\fP) \-\- numpy ndarray of shape (M,N) of N aligned srvfs with M samples
.IP \(bu 2
\fBgam\fP (\fInp.ndarray\fP) \-\- warping functions
.IP \(bu 2
\fBn\fP (\fIinteger\fP) \-\- number of random samples
.IP \(bu 2
\fBsort_samples\fP (\fI\%bool\fP) \-\- sort samples (default = T)
.UNINDENT
.TP
.B Return type
tuple of numpy array
.TP
.B Return fs
random aligned samples
.TP
.B Return gams
random warping functions
.TP
.B Return ft
random samples
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B gauss_model.joint_gauss_model(fn, time, qn, gam, q0, n=1, no=3)
This function models the functional data using a joint Gaussian model
extracted from the principal components of the srsfs
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBfn\fP (\fInp.ndarray\fP) \-\- numpy ndarray of shape (M,N) of N aligned functions with
M samples
.IP \(bu 2
\fBtime\fP (\fInp.ndarray\fP) \-\- vector of size M describing the sample points
.IP \(bu 2
\fBqn\fP (\fInp.ndarray\fP) \-\- numpy ndarray of shape (M,N) of N aligned srsfs with M samples
.IP \(bu 2
\fBgam\fP (\fInp.ndarray\fP) \-\- warping functions
.IP \(bu 2
\fBq0\fP \-\- numpy ndarray of shape (M,N) of N unaligned srsfs with  samples
.IP \(bu 2
\fBn\fP (\fIinteger\fP) \-\- number of random samples
.IP \(bu 2
\fBn\fP \-\- number of principal components (default = 3)
.UNINDENT
.TP
.B Return type
tuple of numpy array
.TP
.B Return fs
random aligned samples
.TP
.B Return gams
random warping functions
.TP
.B Return ft
random samples
.UNINDENT
.UNINDENT
.SH FUNCTIONAL PRINCIPAL LEAST SQUARES
.sp
Partial Least Squares using SVD
.sp
moduleauthor:: Derek Tucker <\fI\%jdtuck@sandia.gov\fP>
.INDENT 0.0
.TP
.B fPLS.pls_svd(time, qf, qg, no, alpha=0.0)
This function computes the partial least squares using SVD
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBtime\fP \-\- vector describing time samples
.IP \(bu 2
\fBqf\fP \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBqg\fP \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBno\fP \-\- number of components
.IP \(bu 2
\fBalpha\fP \-\- amount of smoothing (Default = 0.0 i.e., none)
.UNINDENT
.TP
.B Return type
numpy ndarray
.TP
.B Return wqf
f weight function
.TP
.B Return wqg
g weight function
.TP
.B Return alpha
smoothing value
.TP
.B Return values
singular values
.UNINDENT
.UNINDENT
.SH ELASTIC REGRESSION
.sp
Warping Invariant Regression using SRSF
.sp
moduleauthor:: Derek Tucker <\fI\%jdtuck@sandia.gov\fP>
.INDENT 0.0
.TP
.B regression.elastic_logistic(f, y, time, B=None, df=20, max_itr=20, cores=\-1, smooth=False)
This function identifies a logistic regression model with
phase\-variablity using elastic methods
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBf\fP (\fInp.ndarray\fP) \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBy\fP \-\- numpy array of labels (1/\-1)
.IP \(bu 2
\fBtime\fP (\fInp.ndarray\fP) \-\- vector of size M describing the sample points
.IP \(bu 2
\fBB\fP \-\- optional matrix describing Basis elements
.IP \(bu 2
\fBdf\fP \-\- number of degrees of freedom B\-spline (default 20)
.IP \(bu 2
\fBmax_itr\fP \-\- maximum number of iterations (default 20)
.IP \(bu 2
\fBcores\fP \-\- number of cores for parallel processing (default all)
.UNINDENT
.TP
.B Return type
tuple of numpy array
.TP
.B Return alpha
alpha parameter of model
.TP
.B Return beta
beta(t) of model
.TP
.B Return fn
aligned functions \- numpy ndarray of shape (M,N) of M
.UNINDENT
.sp
functions with N samples
:return qn: aligned srvfs \- similar structure to fn
:return gamma: calculated warping functions
:return q: original training SRSFs
:return B: basis matrix
:return b: basis coefficients
:return Loss: logistic loss
.UNINDENT
.INDENT 0.0
.TP
.B regression.elastic_mlogistic(f, y, time, B=None, df=20, max_itr=20, cores=\-1, delta=0.01, parallel=True, smooth=False)
This function identifies a multinomial logistic regression model with
phase\-variablity using elastic methods
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBf\fP (\fInp.ndarray\fP) \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBy\fP \-\- numpy array of labels {1,2,...,m} for m classes
.IP \(bu 2
\fBtime\fP (\fInp.ndarray\fP) \-\- vector of size M describing the sample points
.IP \(bu 2
\fBB\fP \-\- optional matrix describing Basis elements
.IP \(bu 2
\fBdf\fP \-\- number of degrees of freedom B\-spline (default 20)
.IP \(bu 2
\fBmax_itr\fP \-\- maximum number of iterations (default 20)
.IP \(bu 2
\fBcores\fP \-\- number of cores for parallel processing (default all)
.UNINDENT
.TP
.B Return type
tuple of numpy array
.TP
.B Return alpha
alpha parameter of model
.TP
.B Return beta
beta(t) of model
.TP
.B Return fn
aligned functions \- numpy ndarray of shape (M,N) of N
.UNINDENT
.sp
functions with M samples
:return qn: aligned srvfs \- similar structure to fn
:return gamma: calculated warping functions
:return q: original training SRSFs
:return B: basis matrix
:return b: basis coefficients
:return Loss: logistic loss
.UNINDENT
.INDENT 0.0
.TP
.B regression.elastic_prediction(f, time, model, y=None, smooth=False)
This function performs prediction from an elastic regression model
with phase\-variablity
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBf\fP \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBtime\fP \-\- vector of size M describing the sample points
.IP \(bu 2
\fBmodel\fP \-\- indentified model from elastic_regression
.IP \(bu 2
\fBy\fP \-\- truth, optional used to calculate SSE
.UNINDENT
.TP
.B Return type
tuple of numpy array
.TP
.B Return alpha
alpha parameter of model
.TP
.B Return beta
beta(t) of model
.TP
.B Return fn
aligned functions \- numpy ndarray of shape (M,N) of N
.UNINDENT
.sp
functions with M samples
:return qn: aligned srvfs \- similar structure to fn
:return gamma: calculated warping functions
:return q: original training SRSFs
:return B: basis matrix
:return b: basis coefficients
:return SSE: sum of squared error
.UNINDENT
.INDENT 0.0
.TP
.B regression.elastic_regression(f, y, time, B=None, lam=0, df=20, max_itr=20, cores=\-1, smooth=False)
This function identifies a regression model with phase\-variablity
using elastic methods
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBf\fP (\fInp.ndarray\fP) \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBy\fP \-\- numpy array of N responses
.IP \(bu 2
\fBtime\fP (\fInp.ndarray\fP) \-\- vector of size M describing the sample points
.IP \(bu 2
\fBB\fP \-\- optional matrix describing Basis elements
.IP \(bu 2
\fBlam\fP \-\- regularization parameter (default 0)
.IP \(bu 2
\fBdf\fP \-\- number of degrees of freedom B\-spline (default 20)
.IP \(bu 2
\fBmax_itr\fP \-\- maximum number of iterations (default 20)
.IP \(bu 2
\fBcores\fP \-\- number of cores for parallel processing (default all)
.UNINDENT
.TP
.B Return type
tuple of numpy array
.TP
.B Return alpha
alpha parameter of model
.TP
.B Return beta
beta(t) of model
.TP
.B Return fn
aligned functions \- numpy ndarray of shape (M,N) of M
.UNINDENT
.sp
functions with N samples
:return qn: aligned srvfs \- similar structure to fn
:return gamma: calculated warping functions
:return q: original training SRSFs
:return B: basis matrix
:return b: basis coefficients
:return SSE: sum of squared error
.UNINDENT
.INDENT 0.0
.TP
.B regression.logistic_warp(beta, time, q, y)
calculates optimal warping for function logistic regression
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbeta\fP \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBtime\fP \-\- vector of size N describing the sample points
.IP \(bu 2
\fBq\fP \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBy\fP \-\- numpy ndarray of shape (1,N) responses
.UNINDENT
.TP
.B Return type
numpy array
.TP
.B Return gamma
warping function
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B regression.logit_gradient(b, X, y)
calculates gradient of the logistic loss
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBb\fP \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBX\fP \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBy\fP \-\- numpy ndarray of shape (1,N) responses
.UNINDENT
.TP
.B Return type
numpy array
.TP
.B Return grad
gradient of logisitc loss
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B regression.logit_hessian(s, b, X, y)
calculates hessian of the logistic loss
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBs\fP \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBb\fP \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBX\fP \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBy\fP \-\- numpy ndarray of shape (1,N) responses
.UNINDENT
.TP
.B Return type
numpy array
.TP
.B Return out
hessian of logistic loss
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B regression.logit_loss(b, X, y)
logistic loss function, returns Sum{\-log(phi(t))}
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBb\fP \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBX\fP \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBy\fP \-\- numpy ndarray of shape (1,N) of N responses
.UNINDENT
.TP
.B Return type
numpy array
.TP
.B Return out
loss value
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B regression.mlogit_gradient(b, X, Y)
calculates gradient of the multinomial logistic loss
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBb\fP \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBX\fP \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBy\fP \-\- numpy ndarray of shape (1,N) responses
.UNINDENT
.TP
.B Return type
numpy array
.TP
.B Return grad
gradient
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B regression.mlogit_loss(b, X, Y)
calculates multinomial logistic loss (negative log\-likelihood)
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBb\fP \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBX\fP \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBy\fP \-\- numpy ndarray of shape (1,N) responses
.UNINDENT
.TP
.B Return type
numpy array
.TP
.B Return nll
negative log\-likelihood
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B regression.mlogit_warp_grad(alpha, beta, time, q, y, max_itr=8000, tol=1e\-10, delta=0.008, display=0)
calculates optimal warping for functional multinomial logistic regression
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBalpha\fP \-\- scalar
.IP \(bu 2
\fBbeta\fP \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBtime\fP \-\- vector of size M describing the sample points
.IP \(bu 2
\fBq\fP \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBy\fP \-\- numpy ndarray of shape (1,N) responses
.IP \(bu 2
\fBmax_itr\fP \-\- maximum number of iterations (Default=8000)
.IP \(bu 2
\fBtol\fP \-\- stopping tolerance (Default=1e\-10)
.IP \(bu 2
\fBdelta\fP \-\- gradient step size (Default=0.008)
.IP \(bu 2
\fBdisplay\fP \-\- display iterations (Default=0)
.UNINDENT
.TP
.B Return type
tuple of numpy array
.TP
.B Return gam_old
warping function
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B regression.phi(t)
calculates logistic function, returns 1 / (1 + exp(\-t))
.INDENT 7.0
.TP
.B Parameters
\fBt\fP \-\- scalar
.TP
.B Return type
numpy array
.TP
.B Return out
return value
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B regression.regression_warp(beta, time, q, y, alpha)
calculates optimal warping for function linear regression
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbeta\fP \-\- numpy ndarray of shape (M,N) of M functions with N samples
.IP \(bu 2
\fBtime\fP \-\- vector of size N describing the sample points
.IP \(bu 2
\fBq\fP \-\- numpy ndarray of shape (M,N) of M functions with N samples
.IP \(bu 2
\fBy\fP \-\- numpy ndarray of shape (1,N) of M functions with N samples
.UNINDENT
.UNINDENT
.sp
responses
:param alpha: numpy scalar
.INDENT 7.0
.TP
.B Return type
numpy array
.TP
.B Return gamma_new
warping function
.UNINDENT
.UNINDENT
.SH ELASTIC PRINCIPAL COMPONENT REGRESSION
.sp
Warping PCR Invariant Regression using SRSF
.sp
moduleauthor:: Derek Tucker <\fI\%jdtuck@sandia.gov\fP>
.INDENT 0.0
.TP
.B pcr_regression.elastic_lpcr_regression(f, y, time, pca_method=\(aqcombined\(aq, no=5, smooth_data=False, sparam=25)
This function identifies a logistic regression model with phase\-variability
using elastic pca
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBf\fP (\fInp.ndarray\fP) \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBy\fP \-\- numpy array of N responses
.IP \(bu 2
\fBtime\fP (\fInp.ndarray\fP) \-\- vector of size M describing the sample points
.IP \(bu 2
\fBpca_method\fP \-\- string specifing pca method (options = "combined",
"vert", or "horiz", default = "combined")
.IP \(bu 2
\fBno\fP \-\- scalar specify number of principal components (default=5)
.IP \(bu 2
\fBsmooth_data\fP \-\- smooth data using box filter (default = F)
.IP \(bu 2
\fBsparam\fP \-\- number of times to apply box filter (default = 25)
.UNINDENT
.TP
.B Return type
tuple of numpy array
.TP
.B Return alpha
alpha parameter of model
.TP
.B Return b
regressor vector
.TP
.B Return y
response vector
.TP
.B Return warp_data
alignment object from srsf_align
.TP
.B Return pca
fpca object from corresponding pca method
.TP
.B Return Loss
logistic loss
.TP
.B Return pca.method
string of pca method
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B pcr_regression.elastic_mlpcr_regression(f, y, time, pca_method=\(aqcombined\(aq, no=5, smooth_data=False, sparam=25)
This function identifies a logistic regression model with phase\-variability
using elastic pca
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBf\fP (\fInp.ndarray\fP) \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBy\fP \-\- numpy array of N responses
.IP \(bu 2
\fBtime\fP (\fInp.ndarray\fP) \-\- vector of size M describing the sample points
.IP \(bu 2
\fBpca_method\fP \-\- string specifing pca method (options = "combined",
"vert", or "horiz", default = "combined")
.IP \(bu 2
\fBno\fP \-\- scalar specify number of principal components (default=5)
.IP \(bu 2
\fBsmooth_data\fP \-\- smooth data using box filter (default = F)
.IP \(bu 2
\fBsparam\fP \-\- number of times to apply box filter (default = 25)
.UNINDENT
.TP
.B Return type
tuple of numpy array
.TP
.B Return alpha
alpha parameter of model
.TP
.B Return b
regressor vector
.TP
.B Return y
response vector
.TP
.B Return warp_data
alignment object from srsf_align
.TP
.B Return pca
fpca object from corresponding pca method
.TP
.B Return Loss
logistic loss
.TP
.B Return pca.method
string of pca method
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B pcr_regression.elastic_pcr_regression(f, y, time, pca_method=\(aqcombined\(aq, no=5, smooth_data=False, sparam=25, parallel=False, C=None)
This function identifies a regression model with phase\-variability
using elastic pca
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBf\fP (\fInp.ndarray\fP) \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBy\fP \-\- numpy array of N responses
.IP \(bu 2
\fBtime\fP (\fInp.ndarray\fP) \-\- vector of size M describing the sample points
.IP \(bu 2
\fBpca_method\fP \-\- string specifing pca method (options = "combined",
"vert", or "horiz", default = "combined")
.IP \(bu 2
\fBno\fP \-\- scalar specify number of principal components (default=5)
.IP \(bu 2
\fBsmooth_data\fP \-\- smooth data using box filter (default = F)
.IP \(bu 2
\fBsparam\fP \-\- number of times to apply box filter (default = 25)
.IP \(bu 2
\fBparallel\fP \-\- run in parallel (default = F)
.IP \(bu 2
\fBC\fP \-\- scale balance parameter for combined method (default = None)
.UNINDENT
.TP
.B Return type
tuple of numpy array
.TP
.B Return alpha
alpha parameter of model
.TP
.B Return b
regressor vector
.TP
.B Return y
response vector
.TP
.B Return warp_data
alignment object from srsf_align
.TP
.B Return pca
fpca object from corresponding pca method
.TP
.B Return SSE
sum of squared errors
.TP
.B Return pca.method
string of pca method
.UNINDENT
.UNINDENT
.SH ELASTIC FUNCTIONAL TOLERANCE BOUNDS
.sp
Functional Tolerance Bounds using SRSF
.sp
moduleauthor:: Derek Tucker <\fI\%jdtuck@sandia.gov\fP>
.INDENT 0.0
.TP
.B tolerance.bootTB(f, time, a=0.5, p=0.99, B=500, no=5, parallel=True)
This function computes tolerance bounds for functional data containing
phase and amplitude variation using bootstrap sampling
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBf\fP (\fInp.ndarray\fP) \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBtime\fP (\fInp.ndarray\fP) \-\- vector of size M describing the sample points
.IP \(bu 2
\fBa\fP \-\- confidence level of tolerance bound (default = 0.05)
.IP \(bu 2
\fBp\fP \-\- coverage level of tolerance bound (default = 0.99)
.IP \(bu 2
\fBB\fP \-\- number of bootstrap samples (default = 500)
.IP \(bu 2
\fBno\fP \-\- number of principal components (default = 5)
.IP \(bu 2
\fBparallel\fP \-\- enable parallel processing (default = T)
.UNINDENT
.TP
.B Return type
tuple of boxplot objects
.TP
.B Return amp
amplitude tolerance bounds
.TP
.B Return ph
phase tolerance bounds
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B tolerance.mvtol_region(x, alpha, P, B)
Computes tolerance factor for multivariate normal
.sp
Krishnamoorthy, K. and Mondal, S. (2006), Improved Tolerance Factors for Multivariate Normal
Distributions, Communications in Statistics \- Simulation and Computation, 35, 461–478.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBx\fP \-\- (M,N) matrix defining N variables of M samples
.IP \(bu 2
\fBalpha\fP \-\- confidence level
.IP \(bu 2
\fBP\fP \-\- coverage level
.IP \(bu 2
\fBB\fP \-\- number of bootstrap samples
.UNINDENT
.TP
.B Return type
double
.TP
.B Return tol
tolerance factor
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B tolerance.pcaTB(f, time, a=0.5, p=0.99, no=5, parallel=True)
This function computes tolerance bounds for functional data containing
phase and amplitude variation using fPCA
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBf\fP (\fInp.ndarray\fP) \-\- numpy ndarray of shape (M,N) of N functions with M samples
.IP \(bu 2
\fBtime\fP (\fInp.ndarray\fP) \-\- vector of size M describing the sample points
.IP \(bu 2
\fBa\fP \-\- confidence level of tolerance bound (default = 0.05)
.IP \(bu 2
\fBp\fP \-\- coverage level of tolerance bound (default = 0.99)
.IP \(bu 2
\fBno\fP \-\- number of principal components (default = 5)
.IP \(bu 2
\fBparallel\fP \-\- enable parallel processing (default = T)
.UNINDENT
.TP
.B Return type
tuple of boxplot objects
.TP
.B Return warp
alignment data from time_warping
.TP
.B Return pca
functional pca from jointFPCA
.TP
.B Return tol
tolerance factor
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B tolerance.rwishart(df, p)
Computes a random wishart matrix
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdf\fP \-\- degree of freedom
.IP \(bu 2
\fBp\fP \-\- number of dimensions
.UNINDENT
.TP
.B Return type
double
.TP
.B Return R
matrix
.UNINDENT
.UNINDENT
.SH SRVF GEODESIC COMPUTATION
.sp
geodesic calculation for SRVF (curves) open and closed)
.sp
moduleauthor:: Derek Tucker <\fI\%jdtuck@sandia.gov\fP>
.INDENT 0.0
.TP
.B geodesic.back_parallel_transport(u1, alpha, basis, T=100, k=5)
backwards parallel translates q1 and q2 along manifold
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBu1\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBalpha\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBbasis\fP \-\- list numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBT\fP \-\- Number of samples of curve (Default = 100)
.IP \(bu 2
\fBk\fP \-\- number of samples along path (Default = 5)
.UNINDENT
.TP
.B Return type
numpy ndarray
.TP
.B Return utilde
translated vector
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B geodesic.calc_alphadot(alpha, basis, T=100, k=5)
calculates derivative along the path alpha
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBalpha\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBbasis\fP \-\- list of numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBT\fP \-\- Number of samples of curve (Default = 100)
.IP \(bu 2
\fBk\fP \-\- number of samples along path (Default = 5)
.UNINDENT
.TP
.B Return type
numpy ndarray
.TP
.B Return alphadot
derivative of alpha
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B geodesic.calculate_energy(alphadot, T=100, k=5)
calculates energy along path
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBalphadot\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBT\fP \-\- Number of samples of curve (Default = 100)
.IP \(bu 2
\fBk\fP \-\- number of samples along path (Default = 5)
.UNINDENT
.TP
.B Return type
numpy scalar
.TP
.B Return E
energy
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B geodesic.calculate_gradE(u, utilde, T=100, k=5)
calculates gradient of energy along path
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBu\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fButilde\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBT\fP \-\- Number of samples of curve (Default = 100)
.IP \(bu 2
\fBk\fP \-\- number of samples along path (Default = 5)
.UNINDENT
.TP
.B Return type
numpy scalar
.TP
.B Return gradE
gradient of energy
.TP
.B Return normgradE
norm of gradient of energy
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B geodesic.cov_integral(alpha, alphadot, basis, T=100, k=5)
Calculates covariance along path alpha
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBalpha\fP \-\- numpy ndarray of shape (2,M) of M samples (first curve)
.IP \(bu 2
\fBalphadot\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBbasis\fP \-\- list numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBT\fP \-\- Number of samples of curve (Default = 100)
.IP \(bu 2
\fBk\fP \-\- number of samples along path (Default = 5)
.UNINDENT
.TP
.B Return type
numpy ndarray
.TP
.B Return u
covariance
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B geodesic.find_basis_normal_path(alpha, k=5)
computes orthonormalized basis vectors to the normal space at each of the
k points (q\-functions) of the path alpha
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBalpha\fP \-\- numpy ndarray of shape (2,M) of M samples (path)
.IP \(bu 2
\fBk\fP \-\- number of samples along path (Default = 5)
.UNINDENT
.TP
.B Return type
numpy ndarray
.TP
.B Return basis
basis vectors along the path
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B geodesic.geod_dist_path_strt(beta, k=5)
calculate geodisc distance for path straightening
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbeta\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBk\fP \-\- number of samples along path (Default = 5)
.UNINDENT
.TP
.B Return type
numpy scalar
.TP
.B Return dist
geodesic distance
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B geodesic.geod_sphere(beta1, beta2, k=5)
This function caluclates the geodecis between open curves beta1 and
beta2 with k steps along path
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbeta1\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBbeta2\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBk\fP \-\- number of samples along path (Default = 5)
.UNINDENT
.TP
.B Return type
numpy ndarray
.TP
.B Return dist
geodesic distance
.TP
.B Return path
geodesic path
.TP
.B Return O
rotation matrix
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B geodesic.init_path_geod(beta1, beta2, T=100, k=5)
Initializes a path in cal{C}. beta1, beta2 are already
standardized curves. Creates a path from beta1 to beta2 in
shape space, then projects to the closed shape manifold.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbeta1\fP \-\- numpy ndarray of shape (2,M) of M samples (first curve)
.IP \(bu 2
\fBbeta2\fP \-\- numpy ndarray of shape (2,M) of M samples (end curve)
.IP \(bu 2
\fBT\fP \-\- Number of samples of curve (Default = 100)
.IP \(bu 2
\fBk\fP \-\- number of samples along path (Default = 5)
.UNINDENT
.TP
.B Return type
numpy ndarray
.TP
.B Return alpha
a path between two q\-functions
.TP
.B Return beta
a path between two curves
.TP
.B Return O
rotation matrix
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B geodesic.init_path_rand(beta1, beta_mid, beta2, T=100, k=5)
Initializes a path in cal{C}. beta1, beta_mid beta2 are already
standardized curves. Creates a path from beta1 to beta_mid to beta2 in
shape space, then projects to the closed shape manifold.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbeta1\fP \-\- numpy ndarray of shape (2,M) of M samples (first curve)
.IP \(bu 2
\fBbetamid\fP \-\- numpy ndarray of shape (2,M) of M samples (mid curve)
.IP \(bu 2
\fBbeta2\fP \-\- numpy ndarray of shape (2,M) of M samples (end curve)
.IP \(bu 2
\fBT\fP \-\- Number of samples of curve (Default = 100)
.IP \(bu 2
\fBk\fP \-\- number of samples along path (Default = 5)
.UNINDENT
.TP
.B Return type
numpy ndarray
.TP
.B Return alpha
a path between two q\-functions
.TP
.B Return beta
a path between two curves
.TP
.B Return O
rotation matrix
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B geodesic.path_straightening(beta1, beta2, betamid, init=\(aqrand\(aq, T=100, k=5)
Perform path straigtening to find geodesic between two shapes in either
the space of closed curves or the space of affine standardized curves.
This algorithm follows the steps outlined in section 4.6 of the
manuscript.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbeta1\fP \-\- numpy ndarray of shape (2,M) of M samples (first curve)
.IP \(bu 2
\fBbeta2\fP \-\- numpy ndarray of shape (2,M) of M samples (end curve)
.IP \(bu 2
\fBbetamid\fP \-\- numpy ndarray of shape (2,M) of M samples (mid curve
Default = NULL, only needed for init "rand")
.IP \(bu 2
\fBinit\fP \-\- initilizae path geodesic or random (Default = "rand")
.IP \(bu 2
\fBT\fP \-\- Number of samples of curve (Default = 100)
.IP \(bu 2
\fBk\fP \-\- number of samples along path (Default = 5)
.UNINDENT
.TP
.B Return type
numpy ndarray
.TP
.B Return dist
geodesic distance
.TP
.B Return path
geodesic path
.TP
.B Return pathsqnc
geodesic path sequence
.TP
.B Return E
energy
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B geodesic.update_path(alpha, beta, gradE, delta, T=100, k=5)
Update the path along the direction \-gradE
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBalpha\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBbeta\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBgradE\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBdelta\fP \-\- gradient paramenter
.IP \(bu 2
\fBT\fP \-\- Number of samples of curve (Default = 100)
.IP \(bu 2
\fBk\fP \-\- number of samples along path (Default = 5)
.UNINDENT
.TP
.B Return type
numpy scalar
.TP
.B Return alpha
updated path of srvfs
.TP
.B Return beta
updated path of curves
.UNINDENT
.UNINDENT
.SH UTILITY FUNCTIONS
.sp
Utility functions for SRSF Manipulations
.sp
moduleauthor:: Derek Tucker <\fI\%jdtuck@sandia.gov\fP>
.INDENT 0.0
.TP
.B utility_functions.SqrtMean(gam)
calculates the srsf of warping functions with corresponding shooting vectors
.INDENT 7.0
.TP
.B Parameters
\fBgam\fP \-\- numpy ndarray of shape (M,N) of M warping functions
with N samples
.TP
.B Return type
2 numpy ndarray and vector
.TP
.B Return mu
Karcher mean psi function
.TP
.B Return gam_mu
vector of dim N which is the Karcher mean warping function
.TP
.B Return psi
numpy ndarray of shape (M,N) of M SRSF of the warping functions
.TP
.B Return vec
numpy ndarray of shape (M,N) of M shooting vectors
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B utility_functions.SqrtMeanInverse(gam)
finds the inverse of the mean of the set of the diffeomorphisms gamma
.INDENT 7.0
.TP
.B Parameters
\fBgam\fP \-\- numpy ndarray of shape (M,N) of M warping functions
with N samples
.TP
.B Return type
vector
.TP
.B Return gamI
inverse of gam
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B utility_functions.SqrtMedian(gam)
calculates the median srsf of warping functions with corresponding shooting vectors
.INDENT 7.0
.TP
.B Parameters
\fBgam\fP \-\- numpy ndarray of shape (M,N) of M warping functions
with N samples
.TP
.B Return type
2 numpy ndarray and vector
.TP
.B Return gam_median
Karcher median warping function
.TP
.B Return psi_meidan
vector of dim N which is the Karcher median srsf function
.TP
.B Return psi
numpy ndarray of shape (M,N) of M SRSF of the warping functions
.TP
.B Return vec
numpy ndarray of shape (M,N) of M shooting vectors
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B utility_functions.cumtrapzmid(x, y, c, mid)
cumulative trapezoidal numerical integration taken from midpoint
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBx\fP \-\- vector of size N describing the time samples
.IP \(bu 2
\fBy\fP \-\- vector of size N describing the function
.IP \(bu 2
\fBc\fP \-\- midpoint
.IP \(bu 2
\fBmid\fP \-\- midpiont location
.UNINDENT
.TP
.B Return type
vector
.TP
.B Return fa
cumulative integration
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B utility_functions.diffop(n, binsize=1)
Creates a second order differential operator
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBn\fP \-\- dimension
.IP \(bu 2
\fBbinsize\fP \-\- dx (default = 1)
.UNINDENT
.TP
.B Return type
numpy ndarray
.TP
.B Return m
matrix describing differential operator
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B utility_functions.elastic_distance(f1, f2, time, lam=0.0)
"
calculates the distances between function, where f1 is aligned to
f2. In other words
calculates the elastic distances
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBf1\fP \-\- vector of size N
.IP \(bu 2
\fBf2\fP \-\- vector of size N
.IP \(bu 2
\fBtime\fP \-\- vector of size N describing the sample points
.IP \(bu 2
\fBlam\fP \-\- controls the elasticity (default = 0.0)
.UNINDENT
.TP
.B Return type
scalar
.TP
.B Return Dy
amplitude distance
.TP
.B Return Dx
phase distance
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B utility_functions.f_K_fold(Nobs, K=5)
generates sample indices for K\-fold cross validation
.sp
:param Nobs number of observations
:param K number of folds
.INDENT 7.0
.TP
.B Return type
numpy ndarray
.TP
.B Return train
train indexes (Nobs*(K\-1)/K X K)
.TP
.B Return test
test indexes (Nobs*(1/K) X K)
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B utility_functions.f_to_srsf(f, time, smooth=False)
converts f to a square\-root slope function (SRSF)
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBf\fP \-\- vector of size N samples
.IP \(bu 2
\fBtime\fP \-\- vector of size N describing the sample points
.UNINDENT
.TP
.B Return type
vector
.TP
.B Return q
srsf of f
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B utility_functions.geigen(Amat, Bmat, Cmat)
generalized eigenvalue problem of the form
.sp
max tr L\(aqAM / sqrt(tr L\(aqBL tr M\(aqCM) w.r.t. L and M
.sp
:param Amat numpy ndarray of shape (M,N)
:param Bmat numpy ndarray of shape (M,N)
:param Bmat numpy ndarray of shape (M,N)
.INDENT 7.0
.TP
.B Return type
numpy ndarray
.TP
.B Return values
eigenvalues
.TP
.B Return Lmat
left eigenvectors
.TP
.B Return Mmat
right eigenvectors
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B utility_functions.gradient_spline(time, f, smooth=False)
This function takes the gradient of f using b\-spline smoothing
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBtime\fP \-\- vector of size N describing the sample points
.IP \(bu 2
\fBf\fP \-\- numpy ndarray of shape (M,N) of M functions with N samples
.IP \(bu 2
\fBsmooth\fP \-\- smooth data (default = F)
.UNINDENT
.TP
.B Return type
tuple of numpy ndarray
.TP
.B Return f0
smoothed functions functions
.TP
.B Return g
first derivative of each function
.TP
.B Return g2
second derivative of each function
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B utility_functions.innerprod_q(time, q1, q2)
calculates the innerproduct between two srsfs
.sp
:param time vector descrbing time samples
:param q1 vector of srsf 1
:param q2 vector of srsf 2
.INDENT 7.0
.TP
.B Return type
scalar
.TP
.B Return val
inner product value
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B utility_functions.invertGamma(gam)
finds the inverse of the diffeomorphism gamma
.INDENT 7.0
.TP
.B Parameters
\fBgam\fP \-\- vector describing the warping function
.TP
.B Return type
vector
.TP
.B Return gamI
inverse of gam
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B utility_functions.optimum_reparam(q1, time, q2, method=\(aqDP\(aq, lam=0.0, f1o=0.0, f2o=0.0)
calculates the warping to align srsf q2 to q1
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBq1\fP \-\- vector of size N or array of NxM samples of first SRSF
.IP \(bu 2
\fBtime\fP \-\- vector of size N describing the sample points
.IP \(bu 2
\fBq2\fP \-\- vector of size N or array of NxM samples samples of second SRSF
.IP \(bu 2
\fBmethod\fP \-\- method to apply optimzation (default="DP") options are "DP", "DP2" and "RBFGS"
.IP \(bu 2
\fBlam\fP \-\- controls the amount of elasticity (default = 0.0)
.UNINDENT
.TP
.B Return type
vector
.TP
.B Return gam
describing the warping function used to align q2 with q1
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B utility_functions.optimum_reparam_pair(q, time, q1, q2, lam=0.0)
calculates the warping to align srsf pair q1 and q2 to q
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBq\fP \-\- vector of size N or array of NxM samples of first SRSF
.IP \(bu 2
\fBtime\fP \-\- vector of size N describing the sample points
.IP \(bu 2
\fBq1\fP \-\- vector of size N or array of NxM samples samples of second SRSF
.IP \(bu 2
\fBq2\fP \-\- vector of size N or array of NxM samples samples of second SRSF
.IP \(bu 2
\fBlam\fP \-\- controls the amount of elasticity (default = 0.0)
.UNINDENT
.TP
.B Return type
vector
.TP
.B Return gam
describing the warping function used to align q2 with q1
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B utility_functions.outlier_detection(q, time, mq, k=1.5)
calculates outlier\(aqs using geodesic distances of the SRSFs from the median
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBq\fP \-\- numpy ndarray of N x M of M SRS functions with N samples
.IP \(bu 2
\fBtime\fP \-\- vector of size N describing the sample points
.IP \(bu 2
\fBmq\fP \-\- median calculated using \fBtime_warping.srsf_align()\fP
.IP \(bu 2
\fBk\fP \-\- cutoff threshold (default = 1.5)
.UNINDENT
.TP
.B Returns
q_outlier: outlier functions
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B utility_functions.randomGamma(gam, num)
generates random warping functions
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBgam\fP \-\- numpy ndarray of N x M of M of warping functions
.IP \(bu 2
\fBnum\fP \-\- number of random functions
.UNINDENT
.TP
.B Returns
rgam: random warping functions
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B utility_functions.resamplefunction(x, n)
resample function using n points
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBx\fP \-\- functions
.IP \(bu 2
\fBn\fP \-\- number of points
.UNINDENT
.TP
.B Return type
numpy array
.TP
.B Return xn
resampled function
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B utility_functions.rgam(N, sigma, num)
Generates random warping functions
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBN\fP \-\- length of warping function
.IP \(bu 2
\fBsigma\fP \-\- variance of warping functions
.IP \(bu 2
\fBnum\fP \-\- number of warping functions
.UNINDENT
.TP
.B Returns
gam: numpy ndarray of warping functions
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B utility_functions.smooth_data(f, sparam)
This function smooths a collection of functions using a box filter
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBf\fP \-\- numpy ndarray of shape (M,N) of M functions with N samples
.IP \(bu 2
\fBsparam\fP \-\- Number of times to run box filter (default = 25)
.UNINDENT
.TP
.B Return type
numpy ndarray
.TP
.B Return f
smoothed functions functions
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B utility_functions.srsf_to_f(q, time, f0=0.0)
converts q (srsf) to a function
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBq\fP \-\- vector of size N samples of srsf
.IP \(bu 2
\fBtime\fP \-\- vector of size N describing time sample points
.IP \(bu 2
\fBf0\fP \-\- initial value
.UNINDENT
.TP
.B Return type
vector
.TP
.B Return f
function
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B utility_functions.update_progress(progress)
This function creates a progress bar
.INDENT 7.0
.TP
.B Parameters
\fBprogress\fP \-\- fraction of progress
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B utility_functions.warp_f_gamma(time, f, gam)
warps a function f by gam
.sp
:param time vector describing time samples
:param q vector describing srsf
:param gam vector describing warping function
.INDENT 7.0
.TP
.B Return type
numpy ndarray
.TP
.B Return f_temp
warped srsf
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B utility_functions.warp_q_gamma(time, q, gam)
warps a srsf q by gam
.sp
:param time vector describing time samples
:param q vector describing srsf
:param gam vector describing warping function
.INDENT 7.0
.TP
.B Return type
numpy ndarray
.TP
.B Return q_temp
warped srsf
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B utility_functions.zero_crossing(Y, q, bt, time, y_max, y_min, gmax, gmin)
finds zero\-crossing of optimal gamma, gam = s*gmax + (1\-s)*gmin
from elastic regression model
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBY\fP \-\- response
.IP \(bu 2
\fBq\fP \-\- predicitve function
.IP \(bu 2
\fBbt\fP \-\- basis function
.IP \(bu 2
\fBtime\fP \-\- time samples
.IP \(bu 2
\fBy_max\fP \-\- maximum repsonse for warping function gmax
.IP \(bu 2
\fBy_min\fP \-\- minimum response for warping function gmin
.IP \(bu 2
\fBgmax\fP \-\- max warping function
.IP \(bu 2
\fBgmin\fP \-\- min warping fucntion
.UNINDENT
.TP
.B Return type
numpy array
.TP
.B Return gamma
optimal warping function
.UNINDENT
.UNINDENT
.SH CURVE FUNCTIONS
.sp
functions for SRVF curve manipulations
.sp
moduleauthor:: Derek Tucker <\fI\%jdtuck@sandia.gov\fP>
.INDENT 0.0
.TP
.B curve_functions.calc_j(basis)
Calculates Jacobian matrix from normal basis
.INDENT 7.0
.TP
.B Parameters
\fBbasis\fP \-\- list of numpy ndarray of shape (2,M) of M samples basis
.TP
.B Return type
numpy ndarray
.TP
.B Return j
Jacobian
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B curve_functions.calculate_variance(beta)
This function calculates variance of curve beta
.INDENT 7.0
.TP
.B Parameters
\fBbeta\fP \-\- numpy ndarray of shape (2,M) of M samples
.TP
.B Return type
numpy ndarray
.TP
.B Return variance
variance
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B curve_functions.calculatecentroid(beta)
This function calculates centroid of a parameterized curve
.INDENT 7.0
.TP
.B Parameters
\fBbeta\fP \-\- numpy ndarray of shape (2,M) of M samples
.TP
.B Return type
numpy ndarray
.TP
.B Return centroid
center coordinates
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B curve_functions.curve_to_q(beta)
This function converts curve beta to srvf q
.INDENT 7.0
.TP
.B Parameters
\fBbeta\fP \-\- numpy ndarray of shape (2,M) of M samples
.TP
.B Return type
numpy ndarray
.TP
.B Return q
srvf of curve
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B curve_functions.curve_zero_crossing(Y, beta, bt, y_max, y_min, gmax, gmin)
finds zero\-crossing of optimal gamma, gam = s*gmax + (1\-s)*gmin
from elastic curve regression model
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBY\fP \-\- response
.IP \(bu 2
\fBbeta\fP \-\- predicitve function
.IP \(bu 2
\fBbt\fP \-\- basis function
.IP \(bu 2
\fBy_max\fP \-\- maximum repsonse for warping function gmax
.IP \(bu 2
\fBy_min\fP \-\- minimum response for warping function gmin
.IP \(bu 2
\fBgmax\fP \-\- max warping function
.IP \(bu 2
\fBgmin\fP \-\- min warping fucntion
.UNINDENT
.TP
.B Return type
numpy array
.TP
.B Return gamma
optimal warping function
.TP
.B Return O_hat
rotation matrix
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B curve_functions.find_basis_normal(q)
Finds the basis normal to the srvf
.INDENT 7.0
.TP
.B Parameters
\fBq1\fP \-\- numpy ndarray of shape (2,M) of M samples
.TP
.B Return type
list of numpy ndarray
.TP
.B Return basis
list containing basis vectors
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B curve_functions.find_best_rotation(q1, q2)
This function calculates the best rotation between two srvfs using
procustes rigid alignment
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBq1\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBq2\fP \-\- numpy ndarray of shape (2,M) of M samples
.UNINDENT
.TP
.B Return type
numpy ndarray
.TP
.B Return q2new
optimal rotated q2 to q1
.TP
.B Return R
rotation matrix
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B curve_functions.find_rotation_and_seed_coord(beta1, beta2)
This function returns a candidate list of optimally oriented and
registered (seed) shapes w.r.t. beta1
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbeta1\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBbeta2\fP \-\- numpy ndarray of shape (2,M) of M samples
.UNINDENT
.TP
.B Return type
numpy ndarray
.TP
.B Return beta2new
optimal rotated beta2 to beta1
.TP
.B Return O
rotation matrix
.TP
.B Return tau
seed
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B curve_functions.find_rotation_and_seed_q(q1, q2)
This function returns a candidate list of optimally oriented and
registered (seed) shapes w.r.t. beta1
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBq1\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBq2\fP \-\- numpy ndarray of shape (2,M) of M samples
.UNINDENT
.TP
.B Return type
numpy ndarray
.TP
.B Return beta2new
optimal rotated beta2 to beta1
.TP
.B Return O
rotation matrix
.TP
.B Return tau
seed
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B curve_functions.gram_schmidt(basis)
Performs Gram Schmidt Orthogonlization of a basis_o
.INDENT 7.0
.INDENT 3.5
.INDENT 0.0
.TP
.B param basis
list of numpy ndarray of shape (2,M) of M samples
.TP
.B rtype
list of numpy ndarray
.TP
.B return basis_o
orthogonlized basis
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B curve_functions.group_action_by_gamma(q, gamma)
This function reparamerized srvf q by gamma
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBf\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBgamma\fP \-\- numpy ndarray of shape (2,M) of M samples
.UNINDENT
.TP
.B Return type
numpy ndarray
.TP
.B Return qn
reparatermized srvf
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B curve_functions.group_action_by_gamma_coord(f, gamma)
This function reparamerized curve f by gamma
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBf\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBgamma\fP \-\- numpy ndarray of shape (2,M) of M samples
.UNINDENT
.TP
.B Return type
numpy ndarray
.TP
.B Return fn
reparatermized curve
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B curve_functions.innerprod_q2(q1, q2)
This function calculates the inner product in srvf space
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBq1\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBq2\fP \-\- numpy ndarray of shape (2,M) of M samples
.UNINDENT
.TP
.B Return type
numpy ndarray
.TP
.B Return val
inner product
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B curve_functions.inverse_exp(q1, q2, beta2)
Calculate the inverse exponential to obtain a shooting vector from
q1 to q2 in shape space of open curves
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBq1\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBq2\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBbeta2\fP \-\- numpy ndarray of shape (2,M) of M samples
.UNINDENT
.TP
.B Return type
numpy ndarray
.TP
.B Return v
shooting vectors
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B curve_functions.inverse_exp_coord(beta1, beta2)
Calculate the inverse exponential to obtain a shooting vector from
beta1 to beta2 in shape space of open curves
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbeta1\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBbeta2\fP \-\- numpy ndarray of shape (2,M) of M samples
.UNINDENT
.TP
.B Return type
numpy ndarray
.TP
.B Return v
shooting vectors
.TP
.B Return dist
distance
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B curve_functions.optimum_reparam_curve(q1, q2, lam=0.0)
calculates the warping to align srsf q2 to q1
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBq1\fP \-\- matrix of size nxN or array of NxM samples of first SRVF
.IP \(bu 2
\fBtime\fP \-\- vector of size N describing the sample points
.IP \(bu 2
\fBq2\fP \-\- matrix of size nxN or array of NxM samples samples of second SRVF
.IP \(bu 2
\fBlam\fP \-\- controls the amount of elasticity (default = 0.0)
.UNINDENT
.TP
.B Return type
vector
.TP
.B Return gam
describing the warping function used to align q2 with q1
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B curve_functions.parallel_translate(w, q1, q2, basis, mode=0)
parallel translates q1 and q2 along manifold
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBw\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBq1\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBq2\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBbasis\fP \-\- list of numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBmode\fP \-\- open 0 or closed curves 1 (default 0)
.UNINDENT
.TP
.B Return type
numpy ndarray
.TP
.B Return wbar
translated vector
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B curve_functions.pre_proc_curve(beta, T=100)
This function prepcoessed a curve beta to set of closed curves
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBbeta\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBT\fP \-\- number of samples (default = 100)
.UNINDENT
.TP
.B Return type
numpy ndarray
.TP
.B Return betanew
projected beta
.TP
.B Return qnew
projected srvf
.TP
.B Return A
alignment matrix (not used currently)
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B curve_functions.project_curve(q)
This function projects srvf q to set of close curves
.INDENT 7.0
.TP
.B Parameters
\fBq\fP \-\- numpy ndarray of shape (2,M) of M samples
.TP
.B Return type
numpy ndarray
.TP
.B Return qproj
project srvf
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B curve_functions.project_tangent(w, q, basis)
projects srvf to tangent space w using basis
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBw\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBq\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBbasis\fP \-\- list of numpy ndarray of shape (2,M) of M samples
.UNINDENT
.TP
.B Return type
numpy ndarray
.TP
.B Return wproj
projected q
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B curve_functions.psi(x, a, q)
This function formats variance output
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBx\fP \-\- numpy ndarray of shape (2,M) of M samples curve
.IP \(bu 2
\fBa\fP \-\- numpy ndarray of shape (2,1) mean
.IP \(bu 2
\fBq\fP \-\- numpy ndarray of shape (2,M) of M samples srvf
.UNINDENT
.TP
.B Return type
numpy ndarray
.TP
.B Return psi1
variance
.TP
.B Return psi2
cross variance
.TP
.B Return psi3
curve end
.TP
.B Return psi4
curve end
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B curve_functions.q_to_curve(q)
This function converts srvf to beta
.INDENT 7.0
.TP
.B Parameters
\fBq\fP \-\- numpy ndarray of shape (2,M) of M samples
.TP
.B Return type
numpy ndarray
.TP
.B Return beta
parameterized curve
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B curve_functions.resamplecurve(x, N=100)
This function resamples a curve to have N samples
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBx\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBN\fP \-\- Number of samples for new curve (default = 100)
.UNINDENT
.TP
.B Return type
numpy ndarray
.TP
.B Return xn
resampled curve
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B curve_functions.scale_curve(beta)
scales curve to length 1
.INDENT 7.0
.TP
.B Parameters
\fBbeta\fP \-\- numpy ndarray of shape (2,M) of M samples
.TP
.B Return type
numpy ndarray
.TP
.B Return beta_scaled
scaled curve
.TP
.B Return scale
scale factor used
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B curve_functions.shift_f(f, tau)
shifts a curve f by tau
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBf\fP \-\- numpy ndarray of shape (2,M) of M samples
.IP \(bu 2
\fBtau\fP \-\- scalar
.UNINDENT
.TP
.B Return type
numpy ndarray
.TP
.B Return fn
shifted curve
.UNINDENT
.UNINDENT
.sp
References:
.INDENT 0.0
.INDENT 3.5
Tucker, J. D. 2014, Functional Component Analysis and Regression using Elastic
Methods. Ph.D. Thesis, Florida State University.
.sp
Robinson, D. T. 2012, Function Data Analysis and Partial Shape Matching in the
Square Root Velocity Framework. Ph.D. Thesis, Florida State University.
.sp
Huang, W. 2014, Optimization Algorithms on Riemannian Manifolds with
Applications. Ph.D. Thesis, Florida State University.
.sp
Srivastava, A., Wu, W., Kurtek, S., Klassen, E. and Marron, J. S. (2011).
Registration of Functional Data Using Fisher\-Rao Metric. arXiv:1103.3817v2
[math.ST].
.sp
Tucker, J. D., Wu, W. and Srivastava, A. (2013). Generative models for
functional data using phase and amplitude separation. Computational Statistics
and Data Analysis 61, 50\-66.
.sp
J. D. Tucker, W. Wu, and A. Srivastava, "Phase\-Amplitude Separation of
Proteomics Data Using Extended Fisher\-Rao Metric," Electronic Journal of
Statistics, Vol 8, no. 2. pp 1724\-1733, 2014.
.sp
J. D. Tucker, W. Wu, and A. Srivastava, "Analysis of signals under compositional
noise With applications to SONAR data," IEEE Journal of Oceanic Engineering, Vol
29, no. 2. pp 318\-330, Apr 2014.
.sp
Srivastava, A., Klassen, E., Joshi, S., Jermyn, I., (2011). Shape analysis of
elastic curves in euclidean spaces. Pattern Analysis and Machine Intelligence,
IEEE Transactions on 33 (7), 1415\-1428.
.sp
S. Kurtek, A. Srivastava, and W. Wu. Signal estimation under random
time\-warpings and nonlinear signal alignment. In Proceedings of Neural
Information Processing Systems (NIPS), 2011.
.sp
Wen Huang, Kyle A. Gallivan, Anuj Srivastava, Pierre\-Antoine Absil. "Riemannian
Optimization for Elastic Shape Analysis", Short version, The 21st International
Symposium on Mathematical Theory of Networks and Systems (MTNS 2014).
.sp
Cheng, W., Dryden, I. L., and Huang, X. (2016). Bayesian registration of functions
and curves. Bayesian Analysis, 11(2), 447\-475.
.sp
W. Xie, S. Kurtek, K. Bharath, and Y. Sun, A geometric approach to visualization
of variability in functional data, Journal of American Statistical Association 112
(2017), pp. 979\-993.
.sp
Lu, Y., R. Herbei, and S. Kurtek, 2017: Bayesian registration of functions with a Gaussian process prior. Journal of
Computational and Graphical Statistics, 26, no. 4, 894–904.
.sp
Lee, S. and S. Jung, 2017: Combined analysis of amplitude and phase variations
in functional data. arXiv:1603.01775 [stat.ME], 1\-21.
.sp
J. D. Tucker, J. R. Lewis, and A. Srivastava, “Elastic Functional Principal
Component Regression,” Statistical Analysis and Data Mining, 10.1002/sam.11399, 2018.
.UNINDENT
.UNINDENT
.INDENT 0.0
.IP \(bu 2
genindex
.IP \(bu 2
modindex
.IP \(bu 2
search
.UNINDENT
.SH AUTHOR
J. Derek Tucker
.SH COPYRIGHT
2019, J. Derek Tucker
.\" Generated by docutils manpage writer.
.
